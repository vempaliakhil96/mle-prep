[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mle-prep",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "mle-prep"
    ]
  },
  {
    "objectID": "low-level-design/cache.html",
    "href": "low-level-design/cache.html",
    "title": "Cache",
    "section": "",
    "text": "DoublyLinkedList ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\n\n DoublyLinkedListNode (value, next:__main__.DoublyLinkedListNode=None,\n                       prev:__main__.DoublyLinkedList=None)\n\nInitialize self. See help(type(self)) for accurate signature.",
    "crumbs": [
      "low-level-design",
      "Cache"
    ]
  },
  {
    "objectID": "low-level-design/cache.html#doubly-linkedlist",
    "href": "low-level-design/cache.html#doubly-linkedlist",
    "title": "Cache",
    "section": "",
    "text": "DoublyLinkedList ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\n\n DoublyLinkedListNode (value, next:__main__.DoublyLinkedListNode=None,\n                       prev:__main__.DoublyLinkedList=None)\n\nInitialize self. See help(type(self)) for accurate signature.",
    "crumbs": [
      "low-level-design",
      "Cache"
    ]
  },
  {
    "objectID": "low-level-design/cache.html#storage",
    "href": "low-level-design/cache.html#storage",
    "title": "Cache",
    "section": "Storage",
    "text": "Storage\n\n\nStorage\n\n Storage (capacity)\n\nInitialize self. See help(type(self)) for accurate signature.",
    "crumbs": [
      "low-level-design",
      "Cache"
    ]
  },
  {
    "objectID": "low-level-design/cache.html#eviction-policies",
    "href": "low-level-design/cache.html#eviction-policies",
    "title": "Cache",
    "section": "Eviction policies",
    "text": "Eviction policies\n\n\nLRUPolicy\n\n LRUPolicy ()\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\n\n\nEvictionPolicy\n\n EvictionPolicy ()\n\nHelper class that provides a standard way to create an ABC using inheritance.",
    "crumbs": [
      "low-level-design",
      "Cache"
    ]
  },
  {
    "objectID": "low-level-design/cache.html#cache-class",
    "href": "low-level-design/cache.html#cache-class",
    "title": "Cache",
    "section": "Cache class",
    "text": "Cache class\n\n\nCache\n\n Cache (capacity:int)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nlru_cache = Cache(5)\nactions = [\n    lru_cache.put('1', 'a'),\n    lru_cache.put('2', 'b'),\n    lru_cache.get('1'),\n    lru_cache.put('3', 'c'),\n    lru_cache.put('4', 'd'),\n    lru_cache.put('5', 'e'),\n    lru_cache.put('6', 'f'),\n    lru_cache.get('1'),\n    lru_cache.put('7', 'g'),\n    lru_cache.get('4'),\n    lru_cache.put('8', 'h'),\n]\n\nself.capacity=5 reached key_to_remove='2'\nself.capacity=5 reached key_to_remove='3'\nself.capacity=5 reached key_to_remove='5'",
    "crumbs": [
      "low-level-design",
      "Cache"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-4-median-of-two-sorted-arrays.html",
    "href": "coding-problems/arrays/lc-4-median-of-two-sorted-arrays.html",
    "title": "4. Median of Two Sorted Arrays",
    "section": "",
    "text": "link\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "4. Median of Two Sorted Arrays"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-4-median-of-two-sorted-arrays.html#problem",
    "href": "coding-problems/arrays/lc-4-median-of-two-sorted-arrays.html#problem",
    "title": "4. Median of Two Sorted Arrays",
    "section": "",
    "text": "link\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "4. Median of Two Sorted Arrays"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-4-median-of-two-sorted-arrays.html#constraints",
    "href": "coding-problems/arrays/lc-4-median-of-two-sorted-arrays.html#constraints",
    "title": "4. Median of Two Sorted Arrays",
    "section": "Constraints",
    "text": "Constraints\n\nnums1.length == m\nnums2.length == n\n0 &lt;= m &lt;= 1000\n0 &lt;= n &lt;= 1000\n1 &lt;= m + n &lt;= 2000\n-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6\n\n\nfrom typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:\n        l = len(nums1) + len(nums2)\n        if l%2==1: return self.kth(nums1, nums2, l//2)\n        else: return (self.kth(nums1, nums2, l//2-1)+self.kth(nums1, nums2, l//2))/2\n    \n    def kth(self, a, b, k):\n        if not a or not b: return a[k] if not b else b[k]\n\n        ia, ib = len(a)//2, len(b)//2\n        ma, mb = a[ia], b[ib]\n\n        if ia+ib&lt;k: # k is in the upper half\n            if ma&gt;mb: return self.kth(a, b[ib+1:], k-ib-1) # remove the lower half of b\n            else: return self.kth(a[ia+1:],b, k-ia-1) # remove the lower half of a\n        else: # k is in the lower half\n            if ma&gt;mb: return self.kth(a[:ia], b, k) # remove the upper half of a\n            else: return self.kth(a, b[:ib], k) # remove the upper half of b",
    "crumbs": [
      "coding-problems",
      "arrays",
      "4. Median of Two Sorted Arrays"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-881-boats-to-save-people.html",
    "href": "coding-problems/arrays/lc-881-boats-to-save-people.html",
    "title": "881. Boats to Save People",
    "section": "",
    "text": "Link\nYou are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1:\n\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\nExample 2:\n\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\nExample 3:\n\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "881. Boats to Save People"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-881-boats-to-save-people.html#problem",
    "href": "coding-problems/arrays/lc-881-boats-to-save-people.html#problem",
    "title": "881. Boats to Save People",
    "section": "",
    "text": "Link\nYou are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1:\n\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\nExample 2:\n\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\nExample 3:\n\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "881. Boats to Save People"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-881-boats-to-save-people.html#constraints",
    "href": "coding-problems/arrays/lc-881-boats-to-save-people.html#constraints",
    "title": "881. Boats to Save People",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= people.length &lt;= 5 * 10^4\n1 &lt;= people[i] &lt;= limit &lt;= 3 * 10^4\n\n\nfrom typing import List\n\nclass Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -&gt; int:\n\n        people.sort()\n        cnt, l, r = 0, 0, len(people)-1\n\n        while l&lt;r:\n            # print(f\"{l=}, {r=}\")\n            wt = people[l]+people[r]\n            if wt&lt;=limit:\n                cnt += 1\n                l+=1; r-=1\n            if wt&gt;limit:\n                cnt+=1\n                r-=1\n        return cnt+1 if l==r else cnt",
    "crumbs": [
      "coding-problems",
      "arrays",
      "881. Boats to Save People"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html",
    "href": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html",
    "title": "1004. Max Consecutive Ones III",
    "section": "",
    "text": "link\nGiven a binary array nums and an integer k, return the maximum number of consecutive 1’s in the array if you can flip at most k 0’s.\nExample 1:\n\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\nExample 2:\n\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\nOutput: 10\nExplanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1004. Max Consecutive Ones III"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html#problem",
    "href": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html#problem",
    "title": "1004. Max Consecutive Ones III",
    "section": "",
    "text": "link\nGiven a binary array nums and an integer k, return the maximum number of consecutive 1’s in the array if you can flip at most k 0’s.\nExample 1:\n\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\nExample 2:\n\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\nOutput: 10\nExplanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1004. Max Consecutive Ones III"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html#constraints",
    "href": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html#constraints",
    "title": "1004. Max Consecutive Ones III",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= nums.length &lt;= 10^5\nnums[i] is either 0 or 1.\n0 &lt;= k &lt;= nums.length",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1004. Max Consecutive Ones III"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html#solution",
    "href": "coding-problems/arrays/lc-1004-max-consecutive-ones-iii.html#solution",
    "title": "1004. Max Consecutive Ones III",
    "section": "Solution",
    "text": "Solution\n\nOne thing’s for sure, we will only flip a zero if it extends an existing window of 1s. Otherwise, there’s no point in doing it, right? Think Sliding Window!\nSince we know this problem can be solved using the sliding window construct, we might as well focus in that direction for hints. Basically, in a given window, we can never have &gt; K zeros, right?\nWe don’t have a fixed size window in this case. The window size can grow and shrink depending upon the number of zeros we have (we don’t actually have to flip the zeros here!).\n\n\nfrom typing import List\n\nclass Solution:\n    def longestOnes(self, nums: List[int], k: int) -&gt; int:\n\n        n = len(nums)\n        mx, zeros, i, j = 0, 0, 0, 0\n        while j&lt;n:\n            if nums[j]==0: zeros+=1\n            while zeros&gt;k:\n                if nums[i]==0: zeros-=1\n                i += 1\n            mx = max(mx, j-i+1)\n            j+=1\n        \n        return mx",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1004. Max Consecutive Ones III"
    ]
  },
  {
    "objectID": "coding-problems/arrays/binary-search-types.html",
    "href": "coding-problems/arrays/binary-search-types.html",
    "title": "Types of Binary Search",
    "section": "",
    "text": "Do not exit the search loop until left boundary is strictly greater than right.\nAlways move left/right boundaries pass mid (+/- 1)\n\n\n\n\n\nPick left if to find first element greater than target\nPick right if to find the last element less than target",
    "crumbs": [
      "coding-problems",
      "arrays",
      "Types of Binary Search"
    ]
  },
  {
    "objectID": "coding-problems/arrays/binary-search-types.html#rules",
    "href": "coding-problems/arrays/binary-search-types.html#rules",
    "title": "Types of Binary Search",
    "section": "",
    "text": "Do not exit the search loop until left boundary is strictly greater than right.\nAlways move left/right boundaries pass mid (+/- 1)\n\n\n\n\n\nPick left if to find first element greater than target\nPick right if to find the last element less than target",
    "crumbs": [
      "coding-problems",
      "arrays",
      "Types of Binary Search"
    ]
  },
  {
    "objectID": "coding-problems/arrays/binary-search-types.html#search-for-target-within-a-sorted-array-without-duplicates",
    "href": "coding-problems/arrays/binary-search-types.html#search-for-target-within-a-sorted-array-without-duplicates",
    "title": "Types of Binary Search",
    "section": "Search for target within a sorted array without duplicates",
    "text": "Search for target within a sorted array without duplicates\n\ndef findTarget(nums: List[int], target: int):\n    \n    if not len(nums): return -1\n\n    left, right = 0, len(nums)-1\n\n    while left&lt;=right:\n\n        mid = (left+right)//2\n        val = nums[mid]\n\n        if val==target: return mid  # found the target\n\n        if val&gt;target: right = mid-1 # target is in the left half\n\n        else: left = mid+1 # target is in the right half\n    \n    return -1\n\n\ntest_eq(findTarget([1,2,3,4,5,6,7,8,9], 2), 1)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "Types of Binary Search"
    ]
  },
  {
    "objectID": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-first-element-greater-than-target",
    "href": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-first-element-greater-than-target",
    "title": "Types of Binary Search",
    "section": "Given a sorted integer array and an input target, find the index of first element greater than target",
    "text": "Given a sorted integer array and an input target, find the index of first element greater than target\n\ndef findFirstGreater(nums: List[int], target: int):\n    \n    if not len(nums): return -1\n\n    if target &gt;= nums[-1]: return -1 # no value is &gt; than target \n\n    if target &lt; nums[0]: return 0 # since all values are &gt; than target, pick smallest value \n\n    left, right = 0, len(nums)-1\n\n    while left&lt;=right:\n\n        mid = (left+right)//2\n\n        cv = nums[mid]\n\n        if cv&gt;target: right = mid-1 # this will also ensure in terminating condition, right crosses over left\n\n        if cv&lt;=target: left = mid+1\n    \n    return left\n\n\ntest_eq(findFirstGreater([5,6,7,7,8,8,8], 6), 2)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "Types of Binary Search"
    ]
  },
  {
    "objectID": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-last-element-smaller-than-target",
    "href": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-last-element-smaller-than-target",
    "title": "Types of Binary Search",
    "section": "Given a sorted integer array and an input target, find the index of last element smaller than target",
    "text": "Given a sorted integer array and an input target, find the index of last element smaller than target\n\ndef findLastSmaller(nums: List[int], target: int):\n    \n    if not len(nums): return -1\n\n    if target&lt;=nums[0]: return -1\n\n    if target&gt;nums[-1]: return len(nums)-1\n\n    left, right = 0, len(nums)-1\n\n    while left&lt;=right:\n\n        mid = (left+right)//2\n\n        cv = nums[mid]\n\n        if cv&gt;=target: right=mid-1\n        \n        if cv&lt;target: left=mid+1\n    \n    return right\n\n\ntest_eq(findLastSmaller([1,2,2,3,4,4,4,5,6], 2), 0)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "Types of Binary Search"
    ]
  },
  {
    "objectID": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-first-occurrence-of-target",
    "href": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-first-occurrence-of-target",
    "title": "Types of Binary Search",
    "section": "Given a sorted integer array and an input target, find the index of first occurrence of target",
    "text": "Given a sorted integer array and an input target, find the index of first occurrence of target\n\ndef findFirstTarget(nums: List[int], target: int):\n\n    i = findLastSmaller(nums, target) # next elem of the smallest elem &gt; target could be the only candiate\n\n    if i==-1: return 0 if nums[0]==target else -1 # if such a number doesnt exist it can be because the target is at 0-th index or it does not exist\n\n    i += 1\n\n    if i&gt;=len(nums) or nums[i]!=target: return -1\n\n    return i\n\n\ntest_eq(findFirstTarget([1,1,1,2,2,3], 1), 0)\ntest_eq(findFirstTarget([1,1,1,2,2,3], 2), 3)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "Types of Binary Search"
    ]
  },
  {
    "objectID": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-last-occurrence-of-target",
    "href": "coding-problems/arrays/binary-search-types.html#given-a-sorted-integer-array-and-an-input-target-find-the-index-of-last-occurrence-of-target",
    "title": "Types of Binary Search",
    "section": "Given a sorted integer array and an input target, find the index of last occurrence of target",
    "text": "Given a sorted integer array and an input target, find the index of last occurrence of target\n\ndef findLastTarget(nums: List[int], target: int):\n\n    i = findFirstGreater(nums, target)\n    \n    if i==-1: return len(nums)-1 if nums[-1]==target else -1\n\n    i-=1\n\n    if i&lt;0 or nums[i]!=target: return -1\n\n    return i\n\n\ntest_eq(findLastTarget([1,1,1,2,2,3], 1), 2)\ntest_eq(findLastTarget([1,1,1,2,2,3], 3), 5)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "Types of Binary Search"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-53-max-subarrays.html",
    "href": "coding-problems/arrays/lc-53-max-subarrays.html",
    "title": "53. Maximum Subarray",
    "section": "",
    "text": "link\nGiven an integer array nums, find the subarray with the largest sum, and return its sum. A subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "53. Maximum Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-53-max-subarrays.html#problem",
    "href": "coding-problems/arrays/lc-53-max-subarrays.html#problem",
    "title": "53. Maximum Subarray",
    "section": "",
    "text": "link\nGiven an integer array nums, find the subarray with the largest sum, and return its sum. A subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "53. Maximum Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-53-max-subarrays.html#constraints",
    "href": "coding-problems/arrays/lc-53-max-subarrays.html#constraints",
    "title": "53. Maximum Subarray",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= nums.length &lt;= 105\n-104 &lt;= nums[i] &lt;= 104\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "53. Maximum Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-53-max-subarrays.html#solution",
    "href": "coding-problems/arrays/lc-53-max-subarrays.html#solution",
    "title": "53. Maximum Subarray",
    "section": "Solution",
    "text": "Solution\nApproach is called Kadane’s algorithm. Maintain a variable max_sum and current_sum. Iterate over the array and keep adding the elements to current_sum. If current_sum is less than 0, then reset it to 0. If current_sum is greater than max_sum, then update max_sum. Return max_sum at the end.\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -&gt; int:\n        current_sum, max_sum = float('-inf'), float('-inf')\n        for n in nums:\n            if current_sum &lt; 0:\n                current_sum = n\n            else:\n                current_sum += n\n            max_sum = max(current_sum, max_sum)\n\n        return max_sum",
    "crumbs": [
      "coding-problems",
      "arrays",
      "53. Maximum Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1482-min-days-to-bloom.html",
    "href": "coding-problems/arrays/lc-1482-min-days-to-bloom.html",
    "title": "1482. Minimum Number of Days to Make m Bouquets",
    "section": "",
    "text": "You are given an integer array bloomDay, an integer m and an integer k.\nYou want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\nExample 1:\n\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\nOutput: 3\nExplanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\nExample 2:\n\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\nOutput: -1\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\nExample 3:\n\nInput: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\nOutput: 12\nExplanation: We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: [x, x, x, x, _, x, x]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: [x, x, x, x, x, x, x]\nIt is obvious that we can make two bouquets in different ways.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1482. Minimum Number of Days to Make `m` Bouquets"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1482-min-days-to-bloom.html#problem",
    "href": "coding-problems/arrays/lc-1482-min-days-to-bloom.html#problem",
    "title": "1482. Minimum Number of Days to Make m Bouquets",
    "section": "",
    "text": "You are given an integer array bloomDay, an integer m and an integer k.\nYou want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\nExample 1:\n\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\nOutput: 3\nExplanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\nExample 2:\n\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\nOutput: -1\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\nExample 3:\n\nInput: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\nOutput: 12\nExplanation: We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: [x, x, x, x, _, x, x]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: [x, x, x, x, x, x, x]\nIt is obvious that we can make two bouquets in different ways.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1482. Minimum Number of Days to Make `m` Bouquets"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1482-min-days-to-bloom.html#constraints",
    "href": "coding-problems/arrays/lc-1482-min-days-to-bloom.html#constraints",
    "title": "1482. Minimum Number of Days to Make m Bouquets",
    "section": "Constraints",
    "text": "Constraints\n\nbloomDay.length == n\n1 &lt;= n &lt;= 10^5\n1 &lt;= bloomDay[i] &lt;= 10^9\n1 &lt;= m &lt;= 10^6\n1 &lt;= k &lt;= n",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1482. Minimum Number of Days to Make `m` Bouquets"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1482-min-days-to-bloom.html#solution",
    "href": "coding-problems/arrays/lc-1482-min-days-to-bloom.html#solution",
    "title": "1482. Minimum Number of Days to Make m Bouquets",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -&gt; int:\n        def check(days):\n            flowers = bouquets = 0\n            for bloom in bloomDay:\n                if bloom &gt; days:\n                    flowers = 0\n                else:\n                    bouquets += (flowers+1)//k # if flowers==k, then flowers+1//k=1\n                    flowers = (flowers+1)%k # if flowers==k, then flowers+1%k=0\n            return bouquets&gt;=m\n        \n        l, r = 0, max(bloomDay)+1\n        while l&lt;r:\n            days = (l+r)//2\n            if check(days): r = days\n            else: l = days+1\n        return l if check(l) else -1",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1482. Minimum Number of Days to Make `m` Bouquets"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-153-find-minimum-in-rotated-sorted-array.html",
    "href": "coding-problems/arrays/lc-153-find-minimum-in-rotated-sorted-array.html",
    "title": "153. Find Minimum in Rotated Sorted Array",
    "section": "",
    "text": "Link\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\nExample 3:\n\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "153. Find Minimum in Rotated Sorted Array"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-153-find-minimum-in-rotated-sorted-array.html#problem",
    "href": "coding-problems/arrays/lc-153-find-minimum-in-rotated-sorted-array.html#problem",
    "title": "153. Find Minimum in Rotated Sorted Array",
    "section": "",
    "text": "Link\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\nExample 3:\n\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "153. Find Minimum in Rotated Sorted Array"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-153-find-minimum-in-rotated-sorted-array.html#constraints",
    "href": "coding-problems/arrays/lc-153-find-minimum-in-rotated-sorted-array.html#constraints",
    "title": "153. Find Minimum in Rotated Sorted Array",
    "section": "Constraints",
    "text": "Constraints\n\nn == nums.length\n1 &lt;= n &lt;= 5000\n-5000 &lt;= nums[i] &lt;= 5000\nAll the integers of nums are unique.\nnums is sorted and rotated between 1 and n times.\n\n\nfrom typing import List\n\nclass Solution:\n    def findMin(self, nums: List[int]) -&gt; int:\n        if len(nums)&lt;3: return min(nums)\n        l, r = 0, len(nums)-1\n        while l&lt;r:\n            m = (l+r)//2\n\n            if nums[m-1]&gt;nums[m]&lt;nums[m+1]:\n                return nums[m]\n            if nums[l]&lt;nums[r]:\n                r = m-1\n            else:\n                l = m+1\n        return min(nums)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "153. Find Minimum in Rotated Sorted Array"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html",
    "href": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html",
    "title": "33. Search in Rotated Sorted Array",
    "section": "",
    "text": "link\nThere is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\n\nInput: nums = [1], target = 0\nOutput: -1",
    "crumbs": [
      "coding-problems",
      "arrays",
      "33. Search in Rotated Sorted Array"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html#problem",
    "href": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html#problem",
    "title": "33. Search in Rotated Sorted Array",
    "section": "",
    "text": "link\nThere is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\n\nInput: nums = [1], target = 0\nOutput: -1",
    "crumbs": [
      "coding-problems",
      "arrays",
      "33. Search in Rotated Sorted Array"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html#constraints",
    "href": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html#constraints",
    "title": "33. Search in Rotated Sorted Array",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= nums.length &lt;= 5000\n-10^4 &lt;= nums[i] &lt;= 10^4\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-10^4 &lt;= target &lt;= 10^4",
    "crumbs": [
      "coding-problems",
      "arrays",
      "33. Search in Rotated Sorted Array"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html#solution",
    "href": "coding-problems/arrays/lc-33-search-in-rotated-sorted-array.html#solution",
    "title": "33. Search in Rotated Sorted Array",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        left, right = 0, len(nums)-1\n\n        while left&lt;=right:\n            mid = (left + right)//2\n            \n            print(f\"{left=} {mid=} {right=}\")\n            \n            if nums[mid] == target: return mid\n\n            # check if left half is sorted\n            if nums[left]&lt;=nums[mid]:\n                \n                if nums[left] &lt;= target &lt; nums[mid]: right = mid-1\n                \n                else: left = mid+1\n            # otherwise right half is sorted\n            else:\n\n                if nums[mid] &lt; target &lt;= nums[right]: left = mid+1\n\n                else: right = mid-1\n            \n        return -1",
    "crumbs": [
      "coding-problems",
      "arrays",
      "33. Search in Rotated Sorted Array"
    ]
  },
  {
    "objectID": "coding-problems/queues/lc-649-dota2-senate.html",
    "href": "coding-problems/queues/lc-649-dota2-senate.html",
    "title": "649. Dota2 Senate",
    "section": "",
    "text": "link\nIn the world of Dota2, there are two parties: the Radiant and the Dire.\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\nBan one senator’s right: A senator can make another senator lose all his rights in this and all the following rounds.\nAnnounce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\n\nGiven a string senate representing each senator’s party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\".\nExample 1:\n\nInput: senate = \"RD\"\nOutput: \"Radiant\"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\nExample 2:\n\nInput: senate = \"RDD\"\nOutput: \"Dire\"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator's right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.",
    "crumbs": [
      "coding-problems",
      "queues",
      "649. Dota2 Senate"
    ]
  },
  {
    "objectID": "coding-problems/queues/lc-649-dota2-senate.html#problem",
    "href": "coding-problems/queues/lc-649-dota2-senate.html#problem",
    "title": "649. Dota2 Senate",
    "section": "",
    "text": "link\nIn the world of Dota2, there are two parties: the Radiant and the Dire.\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\nBan one senator’s right: A senator can make another senator lose all his rights in this and all the following rounds.\nAnnounce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\n\nGiven a string senate representing each senator’s party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\".\nExample 1:\n\nInput: senate = \"RD\"\nOutput: \"Radiant\"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\nExample 2:\n\nInput: senate = \"RDD\"\nOutput: \"Dire\"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator's right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.",
    "crumbs": [
      "coding-problems",
      "queues",
      "649. Dota2 Senate"
    ]
  },
  {
    "objectID": "coding-problems/queues/lc-649-dota2-senate.html#constraints",
    "href": "coding-problems/queues/lc-649-dota2-senate.html#constraints",
    "title": "649. Dota2 Senate",
    "section": "Constraints",
    "text": "Constraints\n\nn == senate.length\n1 &lt;= n &lt;= 10^4\nsenate[i] is either 'R' or 'D'.",
    "crumbs": [
      "coding-problems",
      "queues",
      "649. Dota2 Senate"
    ]
  },
  {
    "objectID": "coding-problems/queues/lc-649-dota2-senate.html#solution",
    "href": "coding-problems/queues/lc-649-dota2-senate.html#solution",
    "title": "649. Dota2 Senate",
    "section": "Solution",
    "text": "Solution\n\nfrom collections import deque\n\nclass Solution:\n    def predictPartyVictory(self, senate: str) -&gt; str:\n        \n        n = len(senate)\n\n        rs = deque([i for i, c in enumerate(senate) if c==\"R\"]) # indices of Rs\n        ds = deque([i for i, c in enumerate(senate) if c==\"D\"]) # indices of Ds\n\n        while rs and ds:\n            rix = rs.popleft() # index of the next R\n            dix = ds.popleft() # index of the next D\n\n            if rix&lt;dix: rs.append(n+rix) # if R comes first he can ban the next D and survive for next round\n            \n            else: ds.append(n+dix) # if D comes first he can ban the next R and survive for next round\n        \n        return \"Radiant\" if rs else \"Dire\"",
    "crumbs": [
      "coding-problems",
      "queues",
      "649. Dota2 Senate"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html",
    "href": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html",
    "title": "2542. Maximum Subsequence Score",
    "section": "",
    "text": "link\nYou are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\nFor chosen indices i0, i1, ..., ik - 1, your score is defined as:\n\nThe sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\nIt can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\n\nReturn the maximum possible score.\nA subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\nExample 1:\n\nInput: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\nOutput: 12\nExplanation: \nThe four possible subsequence scores are:\n- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.\n- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. \n- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. \n- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.\nTherefore, we return the max score, which is 12.\nExample 2:\n\nInput: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\nOutput: 30\nExplanation: \nChoosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.",
    "crumbs": [
      "coding-problems",
      "heaps",
      "2542. Maximum Subsequence Score"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html#problem",
    "href": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html#problem",
    "title": "2542. Maximum Subsequence Score",
    "section": "",
    "text": "link\nYou are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\nFor chosen indices i0, i1, ..., ik - 1, your score is defined as:\n\nThe sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\nIt can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\n\nReturn the maximum possible score.\nA subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\nExample 1:\n\nInput: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\nOutput: 12\nExplanation: \nThe four possible subsequence scores are:\n- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.\n- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. \n- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. \n- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.\nTherefore, we return the max score, which is 12.\nExample 2:\n\nInput: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\nOutput: 30\nExplanation: \nChoosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.",
    "crumbs": [
      "coding-problems",
      "heaps",
      "2542. Maximum Subsequence Score"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html#constraints",
    "href": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html#constraints",
    "title": "2542. Maximum Subsequence Score",
    "section": "Constraints",
    "text": "Constraints\n\nn == nums1.length == nums2.length\n1 &lt;= n &lt;= 10^5\n0 &lt;= nums1[i], nums2[j] &lt;= 10^5\n1 &lt;= k &lt;= n",
    "crumbs": [
      "coding-problems",
      "heaps",
      "2542. Maximum Subsequence Score"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html#solution",
    "href": "coding-problems/heaps/lc-2542-maximum-subsequence-score.html#solution",
    "title": "2542. Maximum Subsequence Score",
    "section": "Solution",
    "text": "Solution\n\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -&gt; int:\n        \n        total = res = 0 # total is running sum of nums1 and res is the max score\n        h = []\n\n        for a, b in sorted(list(zip(nums1, nums2)), key=lambda x: x[-1], reverse=True): # sort by b\n            heapq.heappush(h, a)\n            total += a # add a to total\n            if len(h) &gt; k: # if len(h) &gt; k, pop the smallest element\n                total -= heapq.heappop(h)\n            if len(h)==k: # if len(h) == k, calculate the score\n                res = max(res, total*b)\n        return res",
    "crumbs": [
      "coding-problems",
      "heaps",
      "2542. Maximum Subsequence Score"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html",
    "href": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html",
    "title": "23. Merge k Sorted Lists",
    "section": "",
    "text": "Link\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\nExample 2:\n\nInput: lists = []\nOutput: []\nExample 3:\n\nInput: lists = [[]]\nOutput: []",
    "crumbs": [
      "coding-problems",
      "heaps",
      "23. Merge k Sorted Lists"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html#problem",
    "href": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html#problem",
    "title": "23. Merge k Sorted Lists",
    "section": "",
    "text": "Link\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\nExample 2:\n\nInput: lists = []\nOutput: []\nExample 3:\n\nInput: lists = [[]]\nOutput: []",
    "crumbs": [
      "coding-problems",
      "heaps",
      "23. Merge k Sorted Lists"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html#constraints",
    "href": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html#constraints",
    "title": "23. Merge k Sorted Lists",
    "section": "Constraints",
    "text": "Constraints\n\nk == lists.length\n0 &lt;= k &lt;= 10^4\n0 &lt;= lists[i].length &lt;= 500\n-10^4 &lt;= lists[i][j] &lt;= 10^4\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 10^4",
    "crumbs": [
      "coding-problems",
      "heaps",
      "23. Merge k Sorted Lists"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html#solution",
    "href": "coding-problems/heaps/lc-23-merge-k-sorted-lists.html#solution",
    "title": "23. Merge k Sorted Lists",
    "section": "Solution",
    "text": "Solution\n\n# Definition for singly-linked list.\nimport heapq\nfrom  typing import List, Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n        root, curr = None, None\n        nl = []\n        for l in lists:\n            while l:\n                heapq.heappush(nl, l.val)\n                l = l.next\n        while nl:\n            v = heapq.heappop(nl)\n            if root is None:\n                root = ListNode(v)\n                curr = root\n                continue\n            curr.next = ListNode(v)\n            curr = curr.next\n        return root",
    "crumbs": [
      "coding-problems",
      "heaps",
      "23. Merge k Sorted Lists"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html",
    "href": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html",
    "title": "373. Find K Pairs with Smallest Sums",
    "section": "",
    "text": "link\nYou are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\nExample 1:\n\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\nExample 2:\n\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]",
    "crumbs": [
      "coding-problems",
      "heaps",
      "373. Find K Pairs with Smallest Sums"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html#problem",
    "href": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html#problem",
    "title": "373. Find K Pairs with Smallest Sums",
    "section": "",
    "text": "link\nYou are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\nExample 1:\n\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\nExample 2:\n\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]",
    "crumbs": [
      "coding-problems",
      "heaps",
      "373. Find K Pairs with Smallest Sums"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html#constraints",
    "href": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html#constraints",
    "title": "373. Find K Pairs with Smallest Sums",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= nums1.length, nums2.length &lt;= 105\n-109 &lt;= nums1[i], nums2[i] &lt;= 109\nnums1 and nums2 both are sorted in non-decreasing order.\n1 &lt;= k &lt;= 104\nk &lt;= nums1.length * nums2.length",
    "crumbs": [
      "coding-problems",
      "heaps",
      "373. Find K Pairs with Smallest Sums"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html#solution",
    "href": "coding-problems/heaps/lc-373-find-k-pairs-with-smallest-sums.html#solution",
    "title": "373. Find K Pairs with Smallest Sums",
    "section": "Solution",
    "text": "Solution\n\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:\n\n        l1, l2 = len(nums1), len(nums2)\n        i = 0\n        ans = []\n\n        heap = [(nums1[0] + nums2[0], (0,0))]\n        visited = set()\n        visited.add((0,0))\n\n        while k and heap:\n            s, (x, y) = heapq.heappop(heap)\n            ans.append([nums1[x], nums2[y]])\n\n            if x+1&lt;l1 and (x+1,y) not in visited:\n                heapq.heappush(heap, (nums1[x+1]+nums2[y], (x+1, y)))\n                visited.add((x+1, y))\n            if y+1&lt;l2 and (x,y+1) not in visited:\n                heapq.heappush(heap, (nums1[x]+nums2[y+1], (x,y+1)))\n                visited.add((x,y+1))\n            k -= 1\n        \n        return ans",
    "crumbs": [
      "coding-problems",
      "heaps",
      "373. Find K Pairs with Smallest Sums"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-136-single-number.html",
    "href": "coding-problems/math/lc-136-single-number.html",
    "title": "136. Single Number",
    "section": "",
    "text": "link\nGiven a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\n\nInput: nums = [2,2,1]\nOutput: 1\nExample 2:\n\nInput: nums = [4,1,2,1,2]\nOutput: 4\nExample 3:\n\nInput: nums = [1]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "math",
      "136. Single Number"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-136-single-number.html#problem",
    "href": "coding-problems/math/lc-136-single-number.html#problem",
    "title": "136. Single Number",
    "section": "",
    "text": "link\nGiven a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\n\nInput: nums = [2,2,1]\nOutput: 1\nExample 2:\n\nInput: nums = [4,1,2,1,2]\nOutput: 4\nExample 3:\n\nInput: nums = [1]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "math",
      "136. Single Number"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-136-single-number.html#constraints",
    "href": "coding-problems/math/lc-136-single-number.html#constraints",
    "title": "136. Single Number",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= nums.length &lt;= 3 * 104\n-3 * 104 &lt;= nums[i] &lt;= 3 * 104\nEach element in the array appears twice except for one element which appears only once.",
    "crumbs": [
      "coding-problems",
      "math",
      "136. Single Number"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-136-single-number.html#solution",
    "href": "coding-problems/math/lc-136-single-number.html#solution",
    "title": "136. Single Number",
    "section": "Solution",
    "text": "Solution\nJust do XOR operation on all elements of the array. The result will be the single number.\n\nfrom typing import List\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -&gt; int:\n        x = nums[0]\n        for y in nums[1:]: x ^= y\n        return x",
    "crumbs": [
      "coding-problems",
      "math",
      "136. Single Number"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-29-divide-two-integers.html",
    "href": "coding-problems/math/lc-29-divide-two-integers.html",
    "title": "29. Divide Two Integers",
    "section": "",
    "text": "link\nGiven two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For this problem, if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.",
    "crumbs": [
      "coding-problems",
      "math",
      "29. Divide Two Integers"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-29-divide-two-integers.html#problem",
    "href": "coding-problems/math/lc-29-divide-two-integers.html#problem",
    "title": "29. Divide Two Integers",
    "section": "",
    "text": "link\nGiven two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For this problem, if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.",
    "crumbs": [
      "coding-problems",
      "math",
      "29. Divide Two Integers"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-29-divide-two-integers.html#constraints",
    "href": "coding-problems/math/lc-29-divide-two-integers.html#constraints",
    "title": "29. Divide Two Integers",
    "section": "Constraints",
    "text": "Constraints\n\n-2^31 &lt;= dividend, divisor &lt;= 2^31 - 1\ndivisor != 0\n\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n        \n        sign = 1 if dividend*divisor&gt;0 else -1\n        dividend,  divisor = abs(dividend), abs(divisor)\n        \n        q = 0\n        while dividend&gt;=divisor:\n            mul = 1\n            t = divisor \n            while dividend&gt;=t: # keep on increasing the divisor by 2^i times\n                dividend -= t\n                q += mul\n                mul += mul\n                t += t\n        \n        return max(-2147483648, min(q*sign, 2147483647))",
    "crumbs": [
      "coding-problems",
      "math",
      "29. Divide Two Integers"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-137-single-number-ii.html",
    "href": "coding-problems/math/lc-137-single-number-ii.html",
    "title": "137. Single Number II",
    "section": "",
    "text": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
    "crumbs": [
      "coding-problems",
      "math",
      "137. Single Number II"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-137-single-number-ii.html#constraints",
    "href": "coding-problems/math/lc-137-single-number-ii.html#constraints",
    "title": "137. Single Number II",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= nums.length &lt;= 3 * 10^4\n-2^31 &lt;= nums[i] &lt;= 2^31 - 1\nEach element in nums appears exactly three times except for one element which appears once.\n\n\nfrom typing import List\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -&gt; int:\n        s = 0\n        for i in range(32):\n            c = 0\n            for n in nums:\n                if n&(1&lt;&lt;i) == (1&lt;&lt;i): c+=1 # count the number of 1s in the i-th bit\n            s |= (c%3) &lt;&lt; i # set the i-th bit of s to 1 if c%3==1\n        return s if s&lt;(1&lt;&lt;31) else s-(1&lt;&lt;32) # if s is negative, convert it to 32-bit signed integer",
    "crumbs": [
      "coding-problems",
      "math",
      "137. Single Number II"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-50-pow.html",
    "href": "coding-problems/math/lc-50-pow.html",
    "title": "50. Pow(x, n)",
    "section": "",
    "text": "link\nImplement pow(x, n), which calculates x raised to the power n (i.e., \\(x^n\\)).\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25",
    "crumbs": [
      "coding-problems",
      "math",
      "50. Pow(x, n)"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-50-pow.html#problem",
    "href": "coding-problems/math/lc-50-pow.html#problem",
    "title": "50. Pow(x, n)",
    "section": "",
    "text": "link\nImplement pow(x, n), which calculates x raised to the power n (i.e., \\(x^n\\)).\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25",
    "crumbs": [
      "coding-problems",
      "math",
      "50. Pow(x, n)"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-50-pow.html#constraints",
    "href": "coding-problems/math/lc-50-pow.html#constraints",
    "title": "50. Pow(x, n)",
    "section": "Constraints",
    "text": "Constraints\n\n-100.0 &lt; x &lt; 100.0\n-231 &lt;= n &lt;= 231-1\nn is an integer.\nEither x is not zero or n &gt; 0.\n-104 &lt;= xn &lt;= 104",
    "crumbs": [
      "coding-problems",
      "math",
      "50. Pow(x, n)"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-50-pow.html#solution",
    "href": "coding-problems/math/lc-50-pow.html#solution",
    "title": "50. Pow(x, n)",
    "section": "Solution",
    "text": "Solution\n\nclass Solution:\n    def myPow(self, x: float, n: int) -&gt; float:\n        if not n: \n            return 1\n        if n&lt;0: \n            return 1 / self.myPow(x, -n)\n        if n%2: \n            return x * self.myPow(x, n-1)\n        return self.myPow(x*x, n/2)",
    "crumbs": [
      "coding-problems",
      "math",
      "50. Pow(x, n)"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html",
    "href": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html",
    "title": "1584. Min Cost to Connect All Points",
    "section": "",
    "text": "link\nYou are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\n\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation:\n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\nExample 2:\n\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18",
    "crumbs": [
      "coding-problems",
      "graphs",
      "1584. Min Cost to Connect All Points"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html#problem",
    "href": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html#problem",
    "title": "1584. Min Cost to Connect All Points",
    "section": "",
    "text": "link\nYou are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\n\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation:\n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\nExample 2:\n\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18",
    "crumbs": [
      "coding-problems",
      "graphs",
      "1584. Min Cost to Connect All Points"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html#constraints",
    "href": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html#constraints",
    "title": "1584. Min Cost to Connect All Points",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= points.length &lt;= 1000\n-10^6 &lt;= xi, yi &lt;= 10^6\nAll pairs (xi, yi) are distinct.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "1584. Min Cost to Connect All Points"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html#solution",
    "href": "coding-problems/graphs/lc-1584-min-cost-to-connect-all-points.html#solution",
    "title": "1584. Min Cost to Connect All Points",
    "section": "Solution",
    "text": "Solution\n\nimport heapq\nfrom typing import List\n\nclass DisJointSetUnion:\n    def __init__(self, n):\n        self.parents = list(range(n))\n    \n    def find(self, x):\n        if self.parents[x]==x: return x\n        r = self.find(self.parents[x]); return r\n    \n    def union(self, x, y): self.parents[self.find(y)] = self.find(x)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -&gt; int:\n\n        n = len(points)\n        UF = DisJointSetUnion(n)\n        distances = []\n\n        for i in range(n):\n            for j in range(i+1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                d = abs(x1-x2)+abs(y1-y2)\n                heapq.heappush(distances, (d, i, j))\n        \n        count, total_cost = 0, 0\n        while distances:\n            d, i, j = heapq.heappop(distances)\n            if UF.find(i)==UF.find(j) or count==n-1: continue\n            UF.union(i, j)\n            total_cost += d\n            count += 1\n        \n        return total_cost",
    "crumbs": [
      "coding-problems",
      "graphs",
      "1584. Min Cost to Connect All Points"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-909-snakes-and-ladders.html",
    "href": "coding-problems/graphs/lc-909-snakes-and-ladders.html",
    "title": "909. Snakes and Ladders",
    "section": "",
    "text": "link\nYou are given an n x n integer matrix board where the cells are labeled from 1 to \\(n^2\\) in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\nYou start on square 1 of the board. In each move, starting from square curr, do the following:\n\nChoose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].\n\nThis choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.\n\nIf next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.\nThe game ends when you reach the square \\(n^2\\).\n\nA board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and \\(n^2\\) do not have a snake or ladder.\nNote that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\n\nFor example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.\n\nReturn the least number of moves required to reach the square \\(n^2\\). If it is not possible to reach the square, return -1.\n\n\n\nexample1\n\n\nExample 1:\nInput: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\nOutput: 4\nExplanation: \nIn the beginning, you start at square 1 (at row 5, column 0).\nYou decide to move to square 2 and must take the ladder to square 15.\nYou then decide to move to square 17 and must take the snake to square 13.\nYou then decide to move to square 14 and must take the ladder to square 35.\nYou then decide to move to square 36, ending the game.\nThis is the lowest possible number of moves to reach the last square, so return 4.\nExample 2:\n\nInput: board = [[-1,-1],[-1,3]]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "graphs",
      "909. Snakes and Ladders"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-909-snakes-and-ladders.html#problem",
    "href": "coding-problems/graphs/lc-909-snakes-and-ladders.html#problem",
    "title": "909. Snakes and Ladders",
    "section": "",
    "text": "link\nYou are given an n x n integer matrix board where the cells are labeled from 1 to \\(n^2\\) in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\nYou start on square 1 of the board. In each move, starting from square curr, do the following:\n\nChoose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].\n\nThis choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.\n\nIf next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.\nThe game ends when you reach the square \\(n^2\\).\n\nA board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and \\(n^2\\) do not have a snake or ladder.\nNote that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\n\nFor example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.\n\nReturn the least number of moves required to reach the square \\(n^2\\). If it is not possible to reach the square, return -1.\n\n\n\nexample1\n\n\nExample 1:\nInput: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\nOutput: 4\nExplanation: \nIn the beginning, you start at square 1 (at row 5, column 0).\nYou decide to move to square 2 and must take the ladder to square 15.\nYou then decide to move to square 17 and must take the snake to square 13.\nYou then decide to move to square 14 and must take the ladder to square 35.\nYou then decide to move to square 36, ending the game.\nThis is the lowest possible number of moves to reach the last square, so return 4.\nExample 2:\n\nInput: board = [[-1,-1],[-1,3]]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "graphs",
      "909. Snakes and Ladders"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-909-snakes-and-ladders.html#constraints",
    "href": "coding-problems/graphs/lc-909-snakes-and-ladders.html#constraints",
    "title": "909. Snakes and Ladders",
    "section": "Constraints",
    "text": "Constraints\n\nn == board.length == board[i].length\n2 &lt;= n &lt;= 20\nboard[i][j] is either -1 or in the range [1, n2].\nThe squares labeled 1 and \\(n^2\\) do not have any ladders or snakes.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "909. Snakes and Ladders"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-909-snakes-and-ladders.html#solution",
    "href": "coding-problems/graphs/lc-909-snakes-and-ladders.html#solution",
    "title": "909. Snakes and Ladders",
    "section": "Solution",
    "text": "Solution\n\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def snakesAndLadders(self, board: List[List[int]]) -&gt; int:\n        n = len(board)\n        board = board[::-1]\n        board = [l if i%2==0 else l[::-1] for i, l in enumerate(board)]\n        board = [i for l in board for i in l]\n        board = [i-1 if i!=-1 else -1 for i in board]\n\n        q = deque([(0, 0)])\n        visited = set()\n        while q:\n            pos, mvs = q.popleft()\n            if pos==n**2-1:\n                return mvs\n            for p in range(pos+1, min(pos+7, n**2), 1):\n                p = board[p] if board[p]!=-1 else p\n                if p not in visited:\n                    visited.add(p)\n                    q.append((p, mvs+1))\n        \n        return -1",
    "crumbs": [
      "coding-problems",
      "graphs",
      "909. Snakes and Ladders"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html",
    "href": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html",
    "title": "433. Minimum Genetic Mutation",
    "section": "",
    "text": "link\nA gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\nFor example, \"AACCGGTT\" --&gt; \"AACCGGTA\" is one mutation.\n\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\nExample 1:\n\nInput: startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\nOutput: 1\nExample 2:\n\nInput: startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\nOutput: 2",
    "crumbs": [
      "coding-problems",
      "graphs",
      "433. Minimum Genetic Mutation"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html#problem",
    "href": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html#problem",
    "title": "433. Minimum Genetic Mutation",
    "section": "",
    "text": "link\nA gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\nFor example, \"AACCGGTT\" --&gt; \"AACCGGTA\" is one mutation.\n\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\nExample 1:\n\nInput: startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\nOutput: 1\nExample 2:\n\nInput: startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\nOutput: 2",
    "crumbs": [
      "coding-problems",
      "graphs",
      "433. Minimum Genetic Mutation"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html#constraints",
    "href": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html#constraints",
    "title": "433. Minimum Genetic Mutation",
    "section": "Constraints",
    "text": "Constraints\n\n0 &lt;= bank.length &lt;= 10\nstartGene.length == endGene.length == bank[i].length == 8\nstartGene, endGene, and bank[i] consist of only the characters ['A', 'C', 'G', 'T'].",
    "crumbs": [
      "coding-problems",
      "graphs",
      "433. Minimum Genetic Mutation"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html#solution",
    "href": "coding-problems/graphs/lc-433-minimum-genetic-mutation.html#solution",
    "title": "433. Minimum Genetic Mutation",
    "section": "Solution",
    "text": "Solution\nJust find valid neighbors of the start gene and itereatively do BFS and keep exploring neighbours.\n\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -&gt; int:\n\n        def check_diff_cnt(g1, g2):\n            cnt = 0\n            for c1, c2 in zip(g1, g2):\n                if c1!=c2:\n                    cnt += 1\n            return cnt\n        \n        q = deque([(startGene, 0)])\n        visited = set()\n        while q:\n            gene_str, muts = q.popleft()\n            visited.add(gene_str)\n            if gene_str==endGene:\n                return muts\n            \n            for gene_str2 in bank:\n                if check_diff_cnt(gene_str, gene_str2)==1 and gene_str2 not in visited:\n                    q.append((gene_str2, muts+1))\n        \n        return -1",
    "crumbs": [
      "coding-problems",
      "graphs",
      "433. Minimum Genetic Mutation"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-210-course-schedule-2.html",
    "href": "coding-problems/graphs/lc-210-course-schedule-2.html",
    "title": "210. Course Schedule II",
    "section": "",
    "text": "link\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]",
    "crumbs": [
      "coding-problems",
      "graphs",
      "210. Course Schedule II"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-210-course-schedule-2.html#problem",
    "href": "coding-problems/graphs/lc-210-course-schedule-2.html#problem",
    "title": "210. Course Schedule II",
    "section": "",
    "text": "link\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]",
    "crumbs": [
      "coding-problems",
      "graphs",
      "210. Course Schedule II"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-210-course-schedule-2.html#constraints",
    "href": "coding-problems/graphs/lc-210-course-schedule-2.html#constraints",
    "title": "210. Course Schedule II",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= numCourses &lt;= 2000\n0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)\nprerequisites[i].length == 2\n0 &lt;= ai, bi &lt; numCourses\nai != bi\nAll the pairs [ai, bi] are distinct.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "210. Course Schedule II"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-210-course-schedule-2.html#solution",
    "href": "coding-problems/graphs/lc-210-course-schedule-2.html#solution",
    "title": "210. Course Schedule II",
    "section": "Solution",
    "text": "Solution\nFirst check if the graph contains a cycle, if true then there exists no solution. If false, then return the topological order of the graph.\n\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n\n        grph = defaultdict(list)\n        visited = [0]*numCourses\n        stck = []\n\n        for x, y in prerequisites: grph[y].append(x)\n\n        def dfs(n):\n            if visited[n]&gt;0: return True\n            elif visited[n]&lt;0: return False\n\n            visited[n] = -1\n            for ch in grph[n]:\n                if not dfs(ch): return False\n            visited[n] = 1\n            stck.append(n)\n            return True\n        \n        for n in range(numCourses):\n            if not dfs(n): return []\n        \n        return stck[::-1]",
    "crumbs": [
      "coding-problems",
      "graphs",
      "210. Course Schedule II"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-127-word-ladder.html",
    "href": "coding-problems/graphs/lc-127-word-ladder.html",
    "title": "127. Word Ladder",
    "section": "",
    "text": "link\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 &lt;= i &lt;= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nExample 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; cog\", which is 5 words long.\nExample 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "127. Word Ladder"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-127-word-ladder.html#problem",
    "href": "coding-problems/graphs/lc-127-word-ladder.html#problem",
    "title": "127. Word Ladder",
    "section": "",
    "text": "link\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 &lt;= i &lt;= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nExample 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; cog\", which is 5 words long.\nExample 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "127. Word Ladder"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-127-word-ladder.html#constraints",
    "href": "coding-problems/graphs/lc-127-word-ladder.html#constraints",
    "title": "127. Word Ladder",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= beginWord.length &lt;= 10\nendWord.length == beginWord.length\n1 &lt;= wordList.length &lt;= 5000\nwordList[i].length == beginWord.length\nbeginWord, endWord, andwordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "127. Word Ladder"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-127-word-ladder.html#solution",
    "href": "coding-problems/graphs/lc-127-word-ladder.html#solution",
    "title": "127. Word Ladder",
    "section": "Solution",
    "text": "Solution\n\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n\n        if endWord not in wordList: return 0\n\n        wordSet = set(wordList)\n\n        cs = 'abcdefghijklmnopqrstuvwxyz'\n        \n        q = deque([(beginWord, 1)])\n        visited = set()\n        while q:\n            w, cnt = q.popleft()\n            visited.add(w)\n            if w == endWord:\n                return cnt\n            for i in range(len(w)):\n                for c in cs:\n                    nw = w[:i]+c+w[i+1:]\n                    if nw in wordSet and nw not in visited:\n                        q.append((nw, cnt+1))\n        return 0",
    "crumbs": [
      "coding-problems",
      "graphs",
      "127. Word Ladder"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html",
    "href": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html",
    "title": "2812. Find the Safest Path in a Grid",
    "section": "",
    "text": "link\nYou are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:\n\nA cell containing a thief if grid[r][c] = 1\nAn empty cell if grid[r][c] = 0\n\nYou are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves.\nThe safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid.\nReturn the maximum safeness factor of all paths leading to cell (n - 1, n - 1).\nAn adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists.\nThe Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.\n\nExample 1:\nInput: grid = [[1,0,0],[0,0,0],[0,0,1]]\nOutput: 0\nExplanation: All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).\n\nExample 2:\nInput: grid = [[0,0,1],[0,0,0],[0,0,0]]\nOutput: 2\nExplanation: The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.\n\nExample 3:\nInput: grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]\nOutput: 2\nExplanation: The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.\n- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "2812. Find the Safest Path in a Grid"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html#problem",
    "href": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html#problem",
    "title": "2812. Find the Safest Path in a Grid",
    "section": "",
    "text": "link\nYou are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:\n\nA cell containing a thief if grid[r][c] = 1\nAn empty cell if grid[r][c] = 0\n\nYou are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves.\nThe safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid.\nReturn the maximum safeness factor of all paths leading to cell (n - 1, n - 1).\nAn adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists.\nThe Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.\n\nExample 1:\nInput: grid = [[1,0,0],[0,0,0],[0,0,1]]\nOutput: 0\nExplanation: All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).\n\nExample 2:\nInput: grid = [[0,0,1],[0,0,0],[0,0,0]]\nOutput: 2\nExplanation: The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.\n\nExample 3:\nInput: grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]\nOutput: 2\nExplanation: The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.\n- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "2812. Find the Safest Path in a Grid"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html#constraints",
    "href": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html#constraints",
    "title": "2812. Find the Safest Path in a Grid",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= grid.length == n &lt;= 400\ngrid[i].length == n\ngrid[i][j] is either 0 or 1.\nThere is at least one thief in the grid.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "2812. Find the Safest Path in a Grid"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html#solution",
    "href": "coding-problems/graphs/lc-2812-find-the-safest-path-in-a-grid.html#solution",
    "title": "2812. Find the Safest Path in a Grid",
    "section": "Solution",
    "text": "Solution\n\nfrom collections import deque\nfrom typing import List\nimport heapq\n\n\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -&gt; int:\n\n        R, C = len(grid), len(grid[0])\n        dirs = [(1,0), (-1,0), (0,1), (0,-1)]\n        q = deque([])\n        \n        for r in range(R):\n            for c in range(C):\n                if grid[r][c]==1: q.append((r, c, 0)); grid[r][c] = 0\n                else: grid[r][c] = float('inf')\n        visited = set() #bfs\n        while q:\n            r, c, d = q.popleft()\n            if not(0&lt;=r&lt;R) or not(0&lt;=c&lt;C) or (r,c) in visited: continue\n            grid[r][c] = min(grid[r][c], d)\n            visited.add((r,c))\n            for dr, dc in dirs: q.append((r+dr, c+dc, d+1))\n        q = [(-grid[0][0], 0, 0)] # djikstra\n        visited = set()\n        while q:\n            d, r, c = heapq.heappop(q)\n            if not(0&lt;=r&lt;R) or not(0&lt;=c&lt;C) or (r,c) in visited: continue\n            d*=-1\n            visited.add((r,c))\n            if r==R-1 and c==C-1: return min(d, grid[r][c])\n            heapq.heappush(q,(-min(d, grid[r][c]), r+1, c))\n            heapq.heappush(q,(-min(d, grid[r][c]), r, c+1))\n            heapq.heappush(q,(-min(d, grid[r][c]), r-1, c))\n            heapq.heappush(q,(-min(d, grid[r][c]), r, c-1))\n        return 0",
    "crumbs": [
      "coding-problems",
      "graphs",
      "2812. Find the Safest Path in a Grid"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-437-path-sum-iii.html",
    "href": "coding-problems/trees/lc-437-path-sum-iii.html",
    "title": "437. Path Sum III",
    "section": "",
    "text": "link\nGiven the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n\nExample 1:\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n\nExample 2:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3",
    "crumbs": [
      "coding-problems",
      "trees",
      "437. Path Sum III"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-437-path-sum-iii.html#problem",
    "href": "coding-problems/trees/lc-437-path-sum-iii.html#problem",
    "title": "437. Path Sum III",
    "section": "",
    "text": "link\nGiven the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n\nExample 1:\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n\nExample 2:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3",
    "crumbs": [
      "coding-problems",
      "trees",
      "437. Path Sum III"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-437-path-sum-iii.html#constraints",
    "href": "coding-problems/trees/lc-437-path-sum-iii.html#constraints",
    "title": "437. Path Sum III",
    "section": "Constraints",
    "text": "Constraints\n\nThe number of nodes in the tree is in the range [0, 1000].\n-10^9 &lt;= Node.val &lt;= 10^9\n-1000 &lt;= targetSum &lt;= 1000",
    "crumbs": [
      "coding-problems",
      "trees",
      "437. Path Sum III"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-437-path-sum-iii.html#solution",
    "href": "coding-problems/trees/lc-437-path-sum-iii.html#solution",
    "title": "437. Path Sum III",
    "section": "Solution",
    "text": "Solution\n\nfrom collections import defaultdict\nfrom typing import Optional\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int:\n\n        count = 0\n        prefix_sums = defaultdict(int)\n        \n        def dfs(n=root, summ=0):\n            nonlocal count\n            if not n: return n\n\n            summ += n.val\n\n            if summ==targetSum: count += 1 # if there is a prefix sum that equals to targetSum, then there is a path that equals to targetSum\n\n            count += prefix_sums[summ-targetSum] # if there is a prefix sum that equals to summ-targetSum, then there is a path that equals to targetSum\n\n            prefix_sums[summ] += 1\n\n            dfs(n.left, summ)\n            dfs(n.right, summ)\n\n            prefix_sums[summ] -= 1\n        \n        dfs()\n        return count",
    "crumbs": [
      "coding-problems",
      "trees",
      "437. Path Sum III"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-101-symmetric-tree.html",
    "href": "coding-problems/trees/lc-101-symmetric-tree.html",
    "title": "101. Symmetric Tree",
    "section": "",
    "text": "Link\nGiven the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\nExample 1:\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n\nExample 2:\nInput: root = [1,2,2,null,3,null,3]\nOutput: false",
    "crumbs": [
      "coding-problems",
      "trees",
      "101. Symmetric Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-101-symmetric-tree.html#problem",
    "href": "coding-problems/trees/lc-101-symmetric-tree.html#problem",
    "title": "101. Symmetric Tree",
    "section": "",
    "text": "Link\nGiven the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\nExample 1:\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n\nExample 2:\nInput: root = [1,2,2,null,3,null,3]\nOutput: false",
    "crumbs": [
      "coding-problems",
      "trees",
      "101. Symmetric Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-101-symmetric-tree.html#constraints",
    "href": "coding-problems/trees/lc-101-symmetric-tree.html#constraints",
    "title": "101. Symmetric Tree",
    "section": "Constraints",
    "text": "Constraints\n\nThe number of nodes in the tree is in the range [1, 1000].\n-100 &lt;= Node.val &lt;= 100",
    "crumbs": [
      "coding-problems",
      "trees",
      "101. Symmetric Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-101-symmetric-tree.html#solution",
    "href": "coding-problems/trees/lc-101-symmetric-tree.html#solution",
    "title": "101. Symmetric Tree",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:\n\n        if not root: return True\n        \n        def is_symmetric(left_node, right_node):\n            if left_node is None or right_node is None: return left_node==right_node\n\n            return left_node.val==right_node.val and \\\n            is_symmetric(left_node.left, right_node.right) and \\\n                is_symmetric(left_node.right, right_node.left)\n        \n        return is_symmetric(root.left, root.right)",
    "crumbs": [
      "coding-problems",
      "trees",
      "101. Symmetric Tree"
    ]
  },
  {
    "objectID": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html",
    "href": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html",
    "title": "438. Find All Anagrams in a String",
    "section": "",
    "text": "link\nGiven two strings s and p, return an array of all the start indices of p’s anagrams in s. You may return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\n\nInput: s = \"cbaebabacd\", p = \"abc\"\nOutput: [0,6]\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\nExample 2:\n\nInput: s = \"abab\", p = \"ab\"\nOutput: [0,1,2]\nExplanation:\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".",
    "crumbs": [
      "coding-problems",
      "strings",
      "438. Find All Anagrams in a String"
    ]
  },
  {
    "objectID": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html#problem",
    "href": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html#problem",
    "title": "438. Find All Anagrams in a String",
    "section": "",
    "text": "link\nGiven two strings s and p, return an array of all the start indices of p’s anagrams in s. You may return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\n\nInput: s = \"cbaebabacd\", p = \"abc\"\nOutput: [0,6]\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\nExample 2:\n\nInput: s = \"abab\", p = \"ab\"\nOutput: [0,1,2]\nExplanation:\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".",
    "crumbs": [
      "coding-problems",
      "strings",
      "438. Find All Anagrams in a String"
    ]
  },
  {
    "objectID": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html#constraints",
    "href": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html#constraints",
    "title": "438. Find All Anagrams in a String",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= s.length, p.length &lt;= 3 * 10^4\ns and p consist of lowercase English letters.",
    "crumbs": [
      "coding-problems",
      "strings",
      "438. Find All Anagrams in a String"
    ]
  },
  {
    "objectID": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html#solution",
    "href": "coding-problems/strings/lc-438-find-all-anagrams-in-a-string.html#solution",
    "title": "438. Find All Anagrams in a String",
    "section": "Solution",
    "text": "Solution\n\nWhen we meet a character c = s[r], we decrease the cnt[c] by one by cnt[c]--\n\nIf the cnt[c] &lt; 0, it means our window contains char c with the number more than in p, which is invalid.\nSo we need to slide left to make sure cnt[c] &gt;= 0.\n\n\n\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -&gt; List[int]:\n\n        cnt = Counter(p) \n\n        res = []\n        l = 0\n        for r, c in enumerate(s):\n            cnt[c] -= 1\n            while cnt[c] &lt; 0: # if cnt[c] &lt; 0 it means its not part of p, need to reset ptrs\n                cnt[s[l]] += 1 # slide left ptr till cnt[c]==0\n                l += 1 \n            if r-l+1==len(p):\n                res.append(l)\n                \n        return res",
    "crumbs": [
      "coding-problems",
      "strings",
      "438. Find All Anagrams in a String"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-322-coin-change.html",
    "href": "coding-problems/dynamic-programming/lc-322-coin-change.html",
    "title": "322. Coin Change",
    "section": "",
    "text": "Link\nYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "322. Coin Change"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-322-coin-change.html#problem",
    "href": "coding-problems/dynamic-programming/lc-322-coin-change.html#problem",
    "title": "322. Coin Change",
    "section": "",
    "text": "Link\nYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "322. Coin Change"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-322-coin-change.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-322-coin-change.html#constraints",
    "title": "322. Coin Change",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= coins.length &lt;= 12\n1 &lt;= coins[i] &lt;= 231 - 1\n0 &lt;= amount &lt;= 104",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "322. Coin Change"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-322-coin-change.html#solution",
    "href": "coding-problems/dynamic-programming/lc-322-coin-change.html#solution",
    "title": "322. Coin Change",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -&gt; int:\n        dp = [float('inf')] * (amount+1) # dp[i] = min number of coins to make up amount i\n        dp[0] = 0\n        for coin in coins:\n            for i in range(coin, amount+1):\n                # min number of coins to make up amount i \n                # is min of dp[i] and dp[i-coin]+1\n                dp[i] = min(dp[i], dp[i-coin]+1) \n        return dp[amount] if dp[amount] != float('inf') else -1",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "322. Coin Change"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-97-interleaving-string.html",
    "href": "coding-problems/dynamic-programming/lc-97-interleaving-string.html",
    "title": "97. Interleaving String",
    "section": "",
    "text": "Link\nGiven strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\ns = s1 + s2 + ... + sn\nt = t1 + t2 + ... + tm\n|n - m| &lt;= 1\nThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: a + b is the concatenation of strings a and b.\n\nExample 1:\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\nExample 2:\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\nExample 3:\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\nOutput: true",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "97. Interleaving String"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-97-interleaving-string.html#problem",
    "href": "coding-problems/dynamic-programming/lc-97-interleaving-string.html#problem",
    "title": "97. Interleaving String",
    "section": "",
    "text": "Link\nGiven strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\ns = s1 + s2 + ... + sn\nt = t1 + t2 + ... + tm\n|n - m| &lt;= 1\nThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: a + b is the concatenation of strings a and b.\n\nExample 1:\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\nExample 2:\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\nExample 3:\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\nOutput: true",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "97. Interleaving String"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-97-interleaving-string.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-97-interleaving-string.html#constraints",
    "title": "97. Interleaving String",
    "section": "Constraints",
    "text": "Constraints\n\n0 &lt;= s1.length, s2.length &lt;= 100\n0 &lt;= s3.length &lt;= 200\ns1, s2, and s3 consist of lowercase English letters.\n\nFollow up: Could you solve it using only O(s2.length) additional memory space?\n\nfrom functools import lru_cache\nclass Solution:\n    @lru_cache\n    def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool:\n        if len(s1)+len(s2)!=len(s3): return False\n        if s1==\"\" and s2==\"\" and s3==\"\": return True\n        if s1==\"\": return s2==s3\n        if s2==\"\": return s1==s3\n        \n        c1, c2, c3 = s1[0], s2[0], s3[0]\n\n        if c1==c3 and c2==c3: return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\n        elif c1==c3: return self.isInterleave(s1[1:], s2, s3[1:])\n        elif c2==c3: return self.isInterleave(s1, s2[1:], s3[1:])\n        else: return False",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "97. Interleaving String"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-139-word-break.html",
    "href": "coding-problems/dynamic-programming/lc-139-word-break.html",
    "title": "139. Word Break",
    "section": "",
    "text": "link\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\n\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\nExample 2:\n\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "139. Word Break"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-139-word-break.html#problem",
    "href": "coding-problems/dynamic-programming/lc-139-word-break.html#problem",
    "title": "139. Word Break",
    "section": "",
    "text": "link\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\n\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\nExample 2:\n\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "139. Word Break"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-139-word-break.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-139-word-break.html#constraints",
    "title": "139. Word Break",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= s.length &lt;= 300\n1 &lt;= wordDict.length &lt;= 1000\n1 &lt;= wordDict[i].length &lt;= 20\ns and wordDict[i] consist of only lowercase English letters.\nAll the strings of wordDict are unique.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "139. Word Break"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-139-word-break.html#solution",
    "href": "coding-problems/dynamic-programming/lc-139-word-break.html#solution",
    "title": "139. Word Break",
    "section": "Solution",
    "text": "Solution\nTime complexity: let n be the length of the string s and m be the number of words in wordDict. There are n dp states, and each state is loops n^2 times. Time Complexity is \\(O(n^3)\\)\n\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:\n\n        wordDict, n = set(wordDict), len(s)\n\n        dp = [False] * (n+1); dp[n] = True # dp stores if the string starting from i can be segmented into words from dict\n\n        for i in range(n-1, -1, -1):\n            for j in range(i+1, n+1):\n                if dp[j] and s[i:j] in wordDict: # at every ith position check if any jth pointion after it is segmentable, \n                    dp[i] = True; break # then check if word b/w i:j is segmentable\n\n        return dp[0]",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "139. Word Break"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-72-edit-distance.html",
    "href": "coding-problems/dynamic-programming/lc-72-edit-distance.html",
    "title": "72. Edit Distance",
    "section": "",
    "text": "Link\nGiven two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character\n\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -&gt; rorse (replace 'h' with 'r')\nrorse -&gt; rose (remove 'r')\nrose -&gt; ros (remove 'e')\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -&gt; inention (remove 't')\ninention -&gt; enention (replace 'i' with 'e')\nenention -&gt; exention (replace 'n' with 'x')\nexention -&gt; exection (replace 'n' with 'c')\nexection -&gt; execution (insert 'u')",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "72. Edit Distance"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-72-edit-distance.html#problem",
    "href": "coding-problems/dynamic-programming/lc-72-edit-distance.html#problem",
    "title": "72. Edit Distance",
    "section": "",
    "text": "Link\nGiven two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character\n\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -&gt; rorse (replace 'h' with 'r')\nrorse -&gt; rose (remove 'r')\nrose -&gt; ros (remove 'e')\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -&gt; inention (remove 't')\ninention -&gt; enention (replace 'i' with 'e')\nenention -&gt; exention (replace 'n' with 'x')\nexention -&gt; exection (replace 'n' with 'c')\nexection -&gt; execution (insert 'u')",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "72. Edit Distance"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-72-edit-distance.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-72-edit-distance.html#constraints",
    "title": "72. Edit Distance",
    "section": "Constraints",
    "text": "Constraints\n\n0 &lt;= word1.length, word2.length &lt;= 500\nword1 and word2 consist of lowercase English letters.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "72. Edit Distance"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-72-edit-distance.html#solution",
    "href": "coding-problems/dynamic-programming/lc-72-edit-distance.html#solution",
    "title": "72. Edit Distance",
    "section": "Solution",
    "text": "Solution\n\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -&gt; int:\n\n        n, m = len(word1), len(word2)\n        dp = [[0]*(m+1) for _ in range(n+1)]\n        for i in range(m+1): dp[0][i] = i\n        for i in range(n+1): dp[i][0] = i\n\n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if word1[i-1]==word2[j-1]: \n                    dp[i][j] = dp[i-1][j-1]\n                    continue\n                insert = dp[i-1][j]\n                delete = dp[i][j-1]\n                replace = dp[i-1][j-1]\n                dp[i][j] = min(insert, delete, replace)+1\n        return dp[-1][-1]",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "72. Edit Distance"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html",
    "href": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html",
    "title": "63. Unique Paths II",
    "section": "",
    "text": "link\nYou are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 10^9.\n\n\n\nexample 1\n\n\nExample 1:\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n\n\n\nexample 2\n\n\nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "63. Unique Paths II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html#problem",
    "href": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html#problem",
    "title": "63. Unique Paths II",
    "section": "",
    "text": "link\nYou are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 10^9.\n\n\n\nexample 1\n\n\nExample 1:\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n\n\n\nexample 2\n\n\nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "63. Unique Paths II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html#constraints",
    "title": "63. Unique Paths II",
    "section": "Constraints",
    "text": "Constraints\n\nm == obstacleGrid.length\nn == obstacleGrid[i].length\n1 &lt;= m, n &lt;= 100\nobstacleGrid[i][j] is 0 or 1.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "63. Unique Paths II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html#solution",
    "href": "coding-problems/dynamic-programming/lc-63-unique-paths-ii.html#solution",
    "title": "63. Unique Paths II",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:\n\n        if obstacleGrid[0][0] == 1: return 0\n        \n        R, C = len(obstacleGrid), len(obstacleGrid[0])\n\n        dp = [[0 for _ in range(C+1)] for __ in range(R+1)]\n        dp[1][1] = 1\n        for c in range(1, C+1):\n            for r in range(1, R+1):\n                if r==1 and c==1: continue\n                dp[r][c] = dp[r-1][c] + dp[r][c-1] if obstacleGrid[r-1][c-1]!=1 else 0\n\n        return dp[-1][-1]",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "63. Unique Paths II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-120-triangle.html",
    "href": "coding-problems/dynamic-programming/lc-120-triangle.html",
    "title": "120. Triangle",
    "section": "",
    "text": "Link\nGiven a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nExample 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "120. Triangle"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-120-triangle.html#problem",
    "href": "coding-problems/dynamic-programming/lc-120-triangle.html#problem",
    "title": "120. Triangle",
    "section": "",
    "text": "Link\nGiven a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nExample 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "120. Triangle"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-120-triangle.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-120-triangle.html#constraints",
    "title": "120. Triangle",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= triangle.length &lt;= 200\ntriangle[0].length == 1\ntriangle[i].length == triangle[i - 1].length + 1\n-104 &lt;= triangle[i][j] &lt;= 104\n\nFollow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "120. Triangle"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-120-triangle.html#solution",
    "href": "coding-problems/dynamic-programming/lc-120-triangle.html#solution",
    "title": "120. Triangle",
    "section": "Solution",
    "text": "Solution\n\nApproach 1:\n\nfrom functools import lru_cache\nfrom typing import List\n\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:\n\n        @lru_cache\n        def f(l=0, i=0):\n            if l == len(triangle): return 0\n            return triangle[l][i] + min(f(l+1, i), f(l+1, i+1))\n        \n        return f()\n\n\n\nApproach 2:\n\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:\n\n        dp = triangle[-1] # copy the last row of the triangle\n\n        for i in range(len(triangle)-2, -1, -1): # iterate from the second last row to the first row\n            for j in range(len(triangle[i])): # iterate over the elements of the current row\n                dp[j] = triangle[i][j] + min(dp[j], dp[j+1]) # update the dp array with the minimum sum\n        \n            # after each layer, the dp array will store the minimum sum of the path from the current element to the bottom\n        \n        return dp[0]",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "120. Triangle"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-51-n-queens.html",
    "href": "coding-problems/backtracking/lc-51-n-queens.html",
    "title": "51. N-Queens",
    "section": "",
    "text": "Link\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nExample 1:\nInput: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\nExample 2:\n\nInput: n = 1\nOutput: [[\"Q\"]]",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "51. N-Queens"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-51-n-queens.html#problem",
    "href": "coding-problems/backtracking/lc-51-n-queens.html#problem",
    "title": "51. N-Queens",
    "section": "",
    "text": "Link\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nExample 1:\nInput: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\nExample 2:\n\nInput: n = 1\nOutput: [[\"Q\"]]",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "51. N-Queens"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-51-n-queens.html#constraints",
    "href": "coding-problems/backtracking/lc-51-n-queens.html#constraints",
    "title": "51. N-Queens",
    "section": "Constraints:",
    "text": "Constraints:\n\n1 &lt;= n &lt;= 9",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "51. N-Queens"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-51-n-queens.html#solution",
    "href": "coding-problems/backtracking/lc-51-n-queens.html#solution",
    "title": "51. N-Queens",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\nclass Solution:\n    def solveNQueens(self, n: int) -&gt; List[List[str]]:\n\n        cols, ldiags, rdiags = set(), set(), set()\n        state = [[\".\"]*n for _ in range(n)]\n        res = []\n\n        def backtrack(r):\n            if r==n: res.append([\"\".join(row) for row in state]); return\n\n            for c in range(n):\n                diff = r-c\n                summ = r+c\n                \n                if c not in cols and diff not in ldiags and summ not in rdiags:\n                    cols.add(c) # column add\n                    rdiags.add(summ) # right diagonal add\n                    ldiags.add(diff) # left diagonal add\n                    state[r][c] = \"Q\" # place queen\n                    backtrack(r+1) # next row\n                    cols.remove(c) # column remove\n                    rdiags.remove(summ) # right diagonal remove\n                    ldiags.remove(diff) # left diagonal remove\n                    state[r][c] = \".\" # remove queen\n        backtrack(0)\n        return res",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "51. N-Queens"
    ]
  },
  {
    "objectID": "fastai/lecture-1.html",
    "href": "fastai/lecture-1.html",
    "title": "Lecture 1",
    "section": "",
    "text": "Note: you may need to restart the kernel to use updated packages.",
    "crumbs": [
      "fastai",
      "Lecture 1"
    ]
  },
  {
    "objectID": "fastai/lecture-1.html#fetch-the-data",
    "href": "fastai/lecture-1.html#fetch-the-data",
    "title": "Lecture 1",
    "section": "Fetch the data",
    "text": "Fetch the data\n\nfrom fastcore.all import *\n\nBASE_PATH = Path(\"../assets/\")\n\n\nfrom duckduckgo_search import DDGS\n\ndef search_images(term, max_images=200): return L(DDGS().images(term, max_results=max_images)).itemgot('image')\n\n\nurls = search_images('bird photos', max_images=1)\nurls[0]\n\n'https://images.pexels.com/photos/326900/pexels-photo-326900.jpeg?cs=srgb&dl=wood-flight-bird-326900.jpg&fm=jpg'\n\n\n\nfrom fastdownload import download_url\ndest = BASE_PATH / \"lecture-1-bird.jpg\"\ndownload_url(urls[0], dest, show_progress=False)\n\nfrom fastai.vision.all import *\nim = Image.open(dest)\nim.to_thumb(256,256)\n\n\n\n\n\n\n\n\n\ndownload_url(search_images('forest photos', max_images=1)[0], BASE_PATH / 'forest.jpg', show_progress=False)\nImage.open(BASE_PATH / 'forest.jpg').to_thumb(256,256)\n\n\n\n\n\n\n\n\n\nsearches = 'forest','bird'\npath = Path(\"/Users/akhilvempali/Documents/tmp/\")\nfrom time import sleep\n\nfor o in searches:\n    dest = (path/o)\n    dest.mkdir(exist_ok=True, parents=True)\n    download_images(dest, urls=search_images(f'{o} photo'))\n    sleep(10)  # Pause between searches to avoid over-loading server\n    download_images(dest, urls=search_images(f'{o} sun photo'))\n    sleep(10)\n    download_images(dest, urls=search_images(f'{o} shade photo'))\n    sleep(10)\n    resize_images(path/o, max_size=400, dest=path/o)\n\n\nfailed = verify_images(get_image_files(path))\nfailed.map(Path.unlink)\nlen(failed)\n\n18",
    "crumbs": [
      "fastai",
      "Lecture 1"
    ]
  },
  {
    "objectID": "fastai/lecture-1.html#training-the-model",
    "href": "fastai/lecture-1.html#training-the-model",
    "title": "Lecture 1",
    "section": "Training the model",
    "text": "Training the model\n\ndls = DataBlock(\n    blocks=(ImageBlock, CategoryBlock), \n    get_items=get_image_files, \n    splitter=RandomSplitter(valid_pct=0.2, seed=42),\n    get_y=parent_label,\n    item_tfms=[Resize(192, method='squish')]\n).dataloaders(path)\n\ndls.show_batch(max_n=6)\n\n\n\n\n\n\n\n\n\nlearn = vision_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(3)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n1.045456\n0.195682\n0.045226\n00:23\n\n\n\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.182339\n0.083122\n0.015075\n00:17\n\n\n1\n0.099367\n0.093427\n0.020101\n00:17\n\n\n2\n0.063069\n0.085321\n0.025126\n00:15",
    "crumbs": [
      "fastai",
      "Lecture 1"
    ]
  },
  {
    "objectID": "fastai/lecture-1.html#making-predictions",
    "href": "fastai/lecture-1.html#making-predictions",
    "title": "Lecture 1",
    "section": "Making predictions",
    "text": "Making predictions\n\nis_bird,_,probs = learn.predict(PILImage.create(BASE_PATH / 'lecture-1-bird.jpg'))\nprint(f\"This is a: {is_bird}.\")\nprint(f\"Probability it's a bird: {probs[0]:.4f}\")\nImage.open(BASE_PATH / 'lecture-1-bird.jpg').to_thumb(256, 256)\n\n\n\n\n\n\n\n\nThis is a: bird.\nProbability it's a bird: 1.0000\n\n\n\n\n\n\n\n\n\n\nlearn.show_results()",
    "crumbs": [
      "fastai",
      "Lecture 1"
    ]
  },
  {
    "objectID": "ml-system-design/estimation-helpers.html",
    "href": "ml-system-design/estimation-helpers.html",
    "title": "Back of the Envelope Guestimation",
    "section": "",
    "text": "link",
    "crumbs": [
      "ml-system-design",
      "Back of the Envelope Guestimation"
    ]
  },
  {
    "objectID": "ml-system-design/estimation-helpers.html#powers-of-two-table",
    "href": "ml-system-design/estimation-helpers.html#powers-of-two-table",
    "title": "Back of the Envelope Guestimation",
    "section": "Powers of two table",
    "text": "Powers of two table\n\n\n\n2 Power\nApprox Value (Bytes)\nBytes\n10 Power\n\n\n\n\n10\n1 thousand\n1 KB\n\\(1 * 10^3\\)\n\n\n16\n65 thousand\n65 KB\n\\(65 * 10^3\\)\n\n\n20\n1 million\n1 MB\n\\(1 * 10^6\\)\n\n\n30\n1 billion\n1 GB\n\\(1 * 10^9\\)\n\n\n32\n4 billion\n4 GB\n\\(4 * 10^9\\)\n\n\n40\n1 trillion\n1 TB\n\\(1 * 10^{12}\\)\n\n\n50\n1 quadrillion\n1 PB\n\\(1 * 10^{15}\\)",
    "crumbs": [
      "ml-system-design",
      "Back of the Envelope Guestimation"
    ]
  },
  {
    "objectID": "ml-system-design/estimation-helpers.html#latency-comparison-numbers",
    "href": "ml-system-design/estimation-helpers.html#latency-comparison-numbers",
    "title": "Back of the Envelope Guestimation",
    "section": "Latency Comparison Numbers",
    "text": "Latency Comparison Numbers\n\nL1 cache can be accessed 14x faster than L2 cache.\nMain memory access is 20x slower than L2, 200x slower than L1.\nZippy Compression at 250 MB/sec.\nSend data over 1 Gbps network at 100 MB/sec.\nRead sequentially from 1 Gbps Ethernet at 100 MB/sec.\nRead randomly/sequentially from SSD at ~ 1 GB/sec.\nRead sequentially from main memory at 4 GB/sec.\nRead sequentially from disk at30 MB/sec.\nDisk seeks at 100 seeks/sec.\nRound-trips within a data center at 2,000 trips/sec.\nWorld-wide round trips at 6-7 trips/sec.\n1MB sequential read from memory –&gt; 250 micro seconds\n1MB sequential read from ssd –&gt; 4x of memory\n1MB sequential read from disk –&gt; 80x of memory",
    "crumbs": [
      "ml-system-design",
      "Back of the Envelope Guestimation"
    ]
  },
  {
    "objectID": "ml-system-design/estimation-helpers.html#handy-numbers-for-requests-calculations.",
    "href": "ml-system-design/estimation-helpers.html#handy-numbers-for-requests-calculations.",
    "title": "Back of the Envelope Guestimation",
    "section": "Handy numbers for requests calculations.",
    "text": "Handy numbers for requests calculations.\n\n1 million reqs/month   ==  .4 reqs/sec\n2.6 million reqs/month ==  1 req/sec\n5.2 million reqs/month ==  2 req/sec\n10 million reqs/month  ==  4 req/sec\n100 million reqs/month == 40 req/sec\n1 billion reqs/month   == 400 req/sec",
    "crumbs": [
      "ml-system-design",
      "Back of the Envelope Guestimation"
    ]
  },
  {
    "objectID": "basics/sentence-encoder-models.html",
    "href": "basics/sentence-encoder-models.html",
    "title": "Sentence Encoder Models",
    "section": "",
    "text": "A sentence encoder model is a type of neural network designed to generate fixed-length vector representations (embeddings) of sentences, capturing their semantic meaning. These embeddings can then be used for various downstream natural language processing (NLP) tasks, such as text classification, semantic similarity, and information retrieval.",
    "crumbs": [
      "basics",
      "Sentence Encoder Models"
    ]
  },
  {
    "objectID": "basics/sentence-encoder-models.html#key-concepts-and-components-of-sentence-encoder-models",
    "href": "basics/sentence-encoder-models.html#key-concepts-and-components-of-sentence-encoder-models",
    "title": "Sentence Encoder Models",
    "section": "Key Concepts and Components of Sentence Encoder Models",
    "text": "Key Concepts and Components of Sentence Encoder Models\n\n1. Fixed-Length Embeddings:\n\nSentence encoders transform sentences of varying lengths into fixed-size vectors. These vectors encode the semantic information of the sentences in a dense, continuous space.\n\n\n\n2. Neural Network Architectures:\n\nVarious neural network architectures can be used for sentence encoding, including:\n\nRecurrent Neural Networks (RNNs): LSTM (Long Short-Term Memory) and GRU (Gated Recurrent Unit) are popular choices.\nConvolutional Neural Networks (CNNs): CNNs can capture local features and patterns in the text.\nTransformer-based Models: Models like BERT (Bidirectional Encoder Representations from Transformers), RoBERTa, and others are highly effective for sentence encoding due to their ability to capture context and dependencies over long sequences.\n\nUsually the last hidden state of the model is used as the sentence embedding.\nPooling strategies like CLS token, mean pooling, or max pooling are applied to obtain a single vector representation from the sequence of hidden states.\n\n\n\n\n\n3. Training Objectives:\n\nSentence encoder models are trained using various objectives to learn meaningful embeddings:\n\nSupervised Learning: Using labeled data for tasks such as sentence classification or entailment.\nUnsupervised Learning: Using self-supervised objectives like next sentence prediction, masked language modeling, or contrastive learning to learn representations without labeled data.\n\n\n\n\n4. Pretrained Models:\n\nMany sentence encoder models are pretrained on large corpora and can be fine-tuned for specific tasks. Some well-known pretrained sentence encoders include:\n\nBERT: Bidirectional Transformer model pretrained using masked language modeling and next sentence prediction.\nSentence-BERT (SBERT): A modification of BERT optimized for producing sentence embeddings, often fine-tuned on sentence pair tasks like semantic textual similarity.\nUniversal Sentence Encoder (USE): A model by Google that provides high-quality sentence embeddings for various languages and tasks.\nInferSent: A model trained on natural language inference (NLI) data to produce sentence embeddings.",
    "crumbs": [
      "basics",
      "Sentence Encoder Models"
    ]
  },
  {
    "objectID": "basics/sentence-encoder-models.html#applications-of-sentence-encoders",
    "href": "basics/sentence-encoder-models.html#applications-of-sentence-encoders",
    "title": "Sentence Encoder Models",
    "section": "Applications of Sentence Encoders",
    "text": "Applications of Sentence Encoders\n\n1. Semantic Similarity:\n\nDetermining the similarity between sentences by comparing their embeddings. Useful in tasks like paraphrase detection, duplicate question identification, and clustering.\n\n\n\n2. Text Classification:\n\nUsing sentence embeddings as features for classifying text into predefined categories, such as sentiment analysis, topic categorization, and spam detection.\n\n\n\n3. Information Retrieval:\n\nEnhancing search engines by representing queries and documents as embeddings and retrieving the most semantically similar documents.\n\n\n\n4. Question Answering:\n\nEncoding questions and potential answers to match and retrieve the most relevant answers from a database.\n\n\n\n5. Text Summarization:\n\nGenerating summaries by encoding sentences and selecting the most representative ones.\n\n\n\n6. Dialogue Systems:\n\nImproving conversational agents by encoding user inputs and generating contextually relevant responses.",
    "crumbs": [
      "basics",
      "Sentence Encoder Models"
    ]
  },
  {
    "objectID": "basics/sentence-encoder-models.html#example-workflow-with-a-sentence-encoder-model",
    "href": "basics/sentence-encoder-models.html#example-workflow-with-a-sentence-encoder-model",
    "title": "Sentence Encoder Models",
    "section": "Example Workflow with a Sentence Encoder Model",
    "text": "Example Workflow with a Sentence Encoder Model\n\n1. Input Sentence:\n\n“The quick brown fox jumps over the lazy dog.”\n\n\n\n2. Encoding:\n\nThe sentence is passed through the encoder model, which outputs a fixed-length vector representing the sentence.\n\n\n\n3. Vector Representation:\n\nThe resulting embedding might look like this (in practice, it’s a high-dimensional vector):\n\n[0.12, -0.45, 0.78, ..., 0.23]\n\n\n4. Downstream Task:\n\nThe embedding can then be used for tasks such as:\n\nMeasuring similarity with another sentence’s embedding.\nFeeding into a classifier for sentiment analysis.\nUsing in a search system to find related sentences.",
    "crumbs": [
      "basics",
      "Sentence Encoder Models"
    ]
  },
  {
    "objectID": "basics/sentence-encoder-models.html#example-code-using-a-pretrained-model",
    "href": "basics/sentence-encoder-models.html#example-code-using-a-pretrained-model",
    "title": "Sentence Encoder Models",
    "section": "Example Code Using a Pretrained Model",
    "text": "Example Code Using a Pretrained Model\nHere’s an example of how to use a pretrained sentence encoder model from the transformers library:\nfrom transformers import BertTokenizer, BertModel\nimport torch\n\n# Load pre-trained model and tokenizer\ntokenizer = BertTokenizer.from_pretrained('bert-base-uncased')\nmodel = BertModel.from_pretrained('bert-base-uncased')\n\n# Encode a sentence\nsentence = \"The quick brown fox jumps over the lazy dog.\"\ninputs = tokenizer(sentence, return_tensors='pt')\n\n# Forward pass to get embeddings\nwith torch.no_grad():\n    outputs = model(**inputs)\n    sentence_embedding = outputs.last_hidden_state.mean(dim=1)  # mean pooling\n\nprint(sentence_embedding)\nSentence encoder models are fundamental tools in modern NLP, enabling a wide range of applications by providing robust, semantically rich representations of textual data.",
    "crumbs": [
      "basics",
      "Sentence Encoder Models"
    ]
  },
  {
    "objectID": "basics/optimizers.html",
    "href": "basics/optimizers.html",
    "title": "Optimizers",
    "section": "",
    "text": "In deep learning, an optimizer is a crucial component used to adjust the weights of the neural network to minimize the loss function during training. The goal is to find the set of weights that result in the best performance of the model. Here’s a detailed explanation of its use and importance:",
    "crumbs": [
      "basics",
      "Optimizers"
    ]
  },
  {
    "objectID": "basics/optimizers.html#key-functions-of-an-optimizer",
    "href": "basics/optimizers.html#key-functions-of-an-optimizer",
    "title": "Optimizers",
    "section": "Key Functions of an Optimizer",
    "text": "Key Functions of an Optimizer\n\n1. Minimizing the Loss Function:\n\nThe loss function measures how well the neural network’s predictions match the actual data. The optimizer updates the weights in the network to minimize this loss function.\n\n\n\n2. Gradient Computation:\n\nOptimizers use the gradients of the loss function with respect to the network’s weights, computed using backpropagation, to determine how to update the weights. This process involves calculating the derivative of the loss function to understand the direction and magnitude of the changes needed.\n\n\n\n3. Weight Updates:\n\nBased on the computed gradients, the optimizer adjusts the weights. The way these updates are applied depends on the specific algorithm used by the optimizer.",
    "crumbs": [
      "basics",
      "Optimizers"
    ]
  },
  {
    "objectID": "basics/optimizers.html#types-of-optimizers",
    "href": "basics/optimizers.html#types-of-optimizers",
    "title": "Optimizers",
    "section": "Types of Optimizers",
    "text": "Types of Optimizers\nThere are several types of optimizers, each with its own approach to updating weights:\n\n1. Stochastic Gradient Descent (SGD):\n\nBasic Concept: Adjusts weights based on the gradient of the loss function with respect to the weights.\nFormula: \\[ w = w - \\alpha \\cdot \\nabla L(w) \\]\n\n\\(w\\): Weights\n\\(\\alpha\\): Learning rate\n\\(\\nabla L(w)\\): Gradient of the loss function\n\n\n\n\n2. Momentum:\n\nEnhancement to SGD: Helps accelerate gradients vectors in the right directions, leading to faster converging.\nFormula: \\[v = \\beta \\cdot v + \\nabla L(w)\\] and \\[w = w - \\alpha \\cdot v\\]\n\n\\(v\\): Velocity\n\\(\\beta\\): Momentum coefficient\n\n\n\n\n3. RMSprop:\n\nAdaptive Learning Rates: Keeps a moving average of the squared gradients and divides the gradient by the root of this average.\nFormula: \\[v = \\beta \\cdot v + (1 - \\beta) \\cdot (\\nabla L(w))^2\\] and \\[w = w - \\alpha \\cdot \\frac{\\nabla L(w)}{\\sqrt{v}}\\]\n\n\\(v\\): Moving average of squared gradients\n\\(\\beta\\): Decay rate\n\n\n\n\n4. Adam (Adaptive Moment Estimation):\n\nCombines Momentum and RMSprop: Maintains two moving averages (of the gradients and the squared gradients) to adapt the learning rate for each parameter.\nFormula: \\[m = \\beta_1 \\cdot m + (1 - \\beta_1) \\cdot \\nabla L(w)\\], \\[v = \\beta_2 \\cdot v + (1 - \\beta_2) \\cdot (\\nabla L(w))^2\\], and \\[w = w - \\alpha \\cdot \\frac{m}{\\sqrt{v}}\\]\n\n\\(m\\): Moving average of gradients\n\\(v\\): Moving average of squared gradients\n\\(\\beta_1\\) and \\(\\beta_2\\): Decay rates",
    "crumbs": [
      "basics",
      "Optimizers"
    ]
  },
  {
    "objectID": "basics/optimizers.html#importance-of-optimizers",
    "href": "basics/optimizers.html#importance-of-optimizers",
    "title": "Optimizers",
    "section": "Importance of Optimizers",
    "text": "Importance of Optimizers\n\n1. Training Efficiency:\n\nThe choice of optimizer affects the speed at which a model converges to the minimum loss. Some optimizers can significantly speed up training and help escape local minima or saddle points.\n\n\n\n2. Model Performance:\n\nDifferent optimizers may lead to different final model performance due to their strategies for navigating the loss landscape. Choosing the right optimizer can improve the accuracy and generalization of the model.\n\n\n\n3. Stability:\n\nAdvanced optimizers like Adam can provide more stable training by adjusting learning rates and taking into account past gradients.\n\nIn summary, the optimizer is a critical component in the training process of deep learning models, influencing the efficiency, stability, and final performance of the model. Choosing the appropriate optimizer and tuning its hyperparameters is essential for effective model training.",
    "crumbs": [
      "basics",
      "Optimizers"
    ]
  },
  {
    "objectID": "basics/embeddings.html",
    "href": "basics/embeddings.html",
    "title": "Embeddings",
    "section": "",
    "text": "Get word level embeddings, idea to generate these embeddings is to read through large corupus of texts like wikipedia , news, books etc and generate embeddings for words based on the context in which they appear.\n\n\nPredict the current word based on the surrounding words\n\\[ Loss = -log(p(w_t|w_{t-n},...,w_{t-1},w_{t+1}...,w_{t+n})) \\]\n\n\n\nPredict the surrounding words based on the current word\n\\[ Loss = -log(p(w_{t-n},...,w_{t-1},w_{t+1}...,w_{t+n}|w_t)) \\]",
    "crumbs": [
      "basics",
      "Embeddings"
    ]
  },
  {
    "objectID": "basics/embeddings.html#word2vec",
    "href": "basics/embeddings.html#word2vec",
    "title": "Embeddings",
    "section": "",
    "text": "Get word level embeddings, idea to generate these embeddings is to read through large corupus of texts like wikipedia , news, books etc and generate embeddings for words based on the context in which they appear.\n\n\nPredict the current word based on the surrounding words\n\\[ Loss = -log(p(w_t|w_{t-n},...,w_{t-1},w_{t+1}...,w_{t+n})) \\]\n\n\n\nPredict the surrounding words based on the current word\n\\[ Loss = -log(p(w_{t-n},...,w_{t-1},w_{t+1}...,w_{t+n}|w_t)) \\]",
    "crumbs": [
      "basics",
      "Embeddings"
    ]
  },
  {
    "objectID": "basics/embeddings.html#glove",
    "href": "basics/embeddings.html#glove",
    "title": "Embeddings",
    "section": "GloVe",
    "text": "GloVe\nGloVe is a model for distributed word representation. The model is an unsupervised learning algorithm for obtaining vector representations for words. This is achieved by mapping words into a meaningful space where the distance between words is related to semantic similarity.\n\\[Loss = \\sum_{i,j=1}^{V} f(P_{ij})(w_i^T\\tilde{w}_j + b_i + \\tilde{b}_j - log(P_{ij}))^2\\]\nwhere \\(P_{ij}\\) is the probability of word \\(i\\) appearing in the context of word \\(j\\). \\(f\\) is a weighting function that assigns less weight to rare words. \\(w_i\\) and \\(\\tilde{w}_j\\) are the word vectors and \\(b_i\\) and \\(\\tilde{b}_j\\) are the bias terms. \\(V\\) is the vocabulary size.",
    "crumbs": [
      "basics",
      "Embeddings"
    ]
  },
  {
    "objectID": "basics/embeddings.html#hypothetical-document-embeddings-hyde",
    "href": "basics/embeddings.html#hypothetical-document-embeddings-hyde",
    "title": "Embeddings",
    "section": "Hypothetical Document Embeddings (HyDE)",
    "text": "Hypothetical Document Embeddings (HyDE)\nUse an LLM to generate a “fake” document for the input query, embed this fake document and vector search this embedding over the document embeddings in the corpus.",
    "crumbs": [
      "basics",
      "Embeddings"
    ]
  },
  {
    "objectID": "basics/nli-based-models.html",
    "href": "basics/nli-based-models.html",
    "title": "NLI Models",
    "section": "",
    "text": "Natural Language Inference (NLI) models, also known as Recognizing Textual Entailment (RTE) models, are designed to determine the logical relationship between two pieces of text: a premise and a hypothesis. The goal is to classify the relationship between the premise and hypothesis into one of three categories:",
    "crumbs": [
      "basics",
      "NLI Models"
    ]
  },
  {
    "objectID": "basics/nli-based-models.html#key-components-and-concepts-in-nli-models",
    "href": "basics/nli-based-models.html#key-components-and-concepts-in-nli-models",
    "title": "NLI Models",
    "section": "Key Components and Concepts in NLI Models",
    "text": "Key Components and Concepts in NLI Models\n\n1. Premise and Hypothesis:\n\nThe premise is a statement or set of statements that are considered given or known.\nThe hypothesis is another statement that the model must evaluate in the context of the premise.\n\n\n\n2. Model Architecture:\n\nNLI models typically use neural network architectures, including:\n\nRNN-based models: Recurrent Neural Networks (e.g., LSTM, GRU) were initially popular for sequence-to-sequence modeling.\nAttention mechanisms: To focus on relevant parts of the premise and hypothesis.\nTransformer-based models: Modern NLI models often use transformer architectures (e.g., BERT, RoBERTa, DeBERTa) which have proven highly effective due to their ability to capture complex dependencies and contextual information.\n\n\n\n\n3. Training Data:\n\nNLI models are trained on datasets where pairs of premises and hypotheses are labeled with one of the three categories (entailment, contradiction, neutral).\nCommon datasets include:\n\nSNLI (Stanford Natural Language Inference): A large dataset for training and evaluating NLI models.\nMultiNLI (Multi-Genre Natural Language Inference): A more diverse dataset covering multiple genres of spoken and written text.\nANLI (Adversarial NLI): A challenging dataset designed to test models on harder examples.\n\n\n\n\n4. Evaluation Metrics:\n\nNLI models are evaluated using accuracy, which measures the percentage of correct classifications over the total number of examples.\nOther metrics, such as precision, recall, and F1-score, can also be used to provide a more detailed performance analysis.",
    "crumbs": [
      "basics",
      "NLI Models"
    ]
  },
  {
    "objectID": "basics/nli-based-models.html#applications-of-nli-models",
    "href": "basics/nli-based-models.html#applications-of-nli-models",
    "title": "NLI Models",
    "section": "Applications of NLI Models",
    "text": "Applications of NLI Models\n\n1. Question Answering:\n\nEnhancing the understanding of questions and validating if the answers are supported by given texts.\n\n\n\n2. Summarization:\n\nEnsuring that generated summaries correctly entail the important points from the source documents.\n\n\n\n3. Information Retrieval:\n\nImproving the relevance of retrieved documents by verifying if they support or contradict user queries.\n\n\n\n4. Dialogue Systems:\n\nEnhancing the coherence and relevance of responses in conversational agents.\n\n\n\n5. Fact-Checking:\n\nAutomatically validating the truthfulness of statements by comparing them against known facts or reliable sources.",
    "crumbs": [
      "basics",
      "NLI Models"
    ]
  },
  {
    "objectID": "basics/nli-based-models.html#example-of-nli-model-workflow",
    "href": "basics/nli-based-models.html#example-of-nli-model-workflow",
    "title": "NLI Models",
    "section": "Example of NLI Model Workflow",
    "text": "Example of NLI Model Workflow\n\n1. Input:\n\nPremise: “A man is playing a guitar.”\nHypothesis: “A man is making music.”\n\n\n\n2. Model Processing:\n\nThe model encodes both the premise and hypothesis using a neural network.\nIt then compares the encoded representations to determine their relationship.\n\n\n\n3. Output:\n\nThe model predicts one of the three categories: entailment, contradiction, or neutral. In this case, the hypothesis (“A man is making music.”) is an entailment of the premise (“A man is playing a guitar.”).\n\nNLI models are crucial for advanced natural language understanding tasks and continue to be an active area of research in the field of artificial intelligence and machine learning.",
    "crumbs": [
      "basics",
      "NLI Models"
    ]
  },
  {
    "objectID": "misc/titanic-prediction.html",
    "href": "misc/titanic-prediction.html",
    "title": "Titanic Dataset prediction",
    "section": "",
    "text": "! pip install -U kaggle seaborn pandas --quiet\n\n\nimport kaggle\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, confusion_matrix, f1_score, precision_score, recall_score, log_loss\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom fastai.imports import *\n\nnp.set_printoptions(linewidth=130)\n\n\npath = Path(\"/tmp/\")\nkaggle.api.competition_download_files(\"titanic\", force=True, path=path)\nfiles = [\"train.csv\", \"test.csv\", \"gender_submission.csv\"]\n! rm {\" \".join(str(path / f) for f in files)}\n! unzip {path / \"titanic.zip\"} -d {path}\n\nArchive:  /tmp/titanic.zip\n  inflating: /tmp/gender_submission.csv  \n  inflating: /tmp/test.csv           \n  inflating: /tmp/train.csv          \n\n\n\ntrain = pd.read_csv(path / \"train.csv\")\ntrain.head(2)\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Thayer)\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n\n\n\n\n\n\ntest = pd.read_csv(path / \"test.csv\")\ntest.head(2)\n\n\n\n\n\n\n\n\nPassengerId\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n892\n3\nKelly, Mr. James\nmale\n34.5\n0\n0\n330911\n7.8292\nNaN\nQ\n\n\n1\n893\n3\nWilkes, Mrs. James (Ellen Needs)\nfemale\n47.0\n1\n0\n363272\n7.0000\nNaN\nS\n\n\n\n\n\n\n\n\nsample_submission = pd.read_csv(path / \"gender_submission.csv\")\nsample_submission.head(2)\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\n\n\n\n\n0\n892\n0\n\n\n1\n893\n1",
    "crumbs": [
      "misc",
      "Titanic Dataset prediction"
    ]
  },
  {
    "objectID": "misc/titanic-prediction.html#setup",
    "href": "misc/titanic-prediction.html#setup",
    "title": "Titanic Dataset prediction",
    "section": "",
    "text": "! pip install -U kaggle seaborn pandas --quiet\n\n\nimport kaggle\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, confusion_matrix, f1_score, precision_score, recall_score, log_loss\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom fastai.imports import *\n\nnp.set_printoptions(linewidth=130)\n\n\npath = Path(\"/tmp/\")\nkaggle.api.competition_download_files(\"titanic\", force=True, path=path)\nfiles = [\"train.csv\", \"test.csv\", \"gender_submission.csv\"]\n! rm {\" \".join(str(path / f) for f in files)}\n! unzip {path / \"titanic.zip\"} -d {path}\n\nArchive:  /tmp/titanic.zip\n  inflating: /tmp/gender_submission.csv  \n  inflating: /tmp/test.csv           \n  inflating: /tmp/train.csv          \n\n\n\ntrain = pd.read_csv(path / \"train.csv\")\ntrain.head(2)\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Thayer)\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n\n\n\n\n\n\ntest = pd.read_csv(path / \"test.csv\")\ntest.head(2)\n\n\n\n\n\n\n\n\nPassengerId\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n892\n3\nKelly, Mr. James\nmale\n34.5\n0\n0\n330911\n7.8292\nNaN\nQ\n\n\n1\n893\n3\nWilkes, Mrs. James (Ellen Needs)\nfemale\n47.0\n1\n0\n363272\n7.0000\nNaN\nS\n\n\n\n\n\n\n\n\nsample_submission = pd.read_csv(path / \"gender_submission.csv\")\nsample_submission.head(2)\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\n\n\n\n\n0\n892\n0\n\n\n1\n893\n1",
    "crumbs": [
      "misc",
      "Titanic Dataset prediction"
    ]
  },
  {
    "objectID": "misc/titanic-prediction.html#eda",
    "href": "misc/titanic-prediction.html#eda",
    "title": "Titanic Dataset prediction",
    "section": "EDA",
    "text": "EDA\n\ntrain.describe()\n\n\n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nAge\nSibSp\nParch\nFare\n\n\n\n\ncount\n891.000000\n891.000000\n891.000000\n714.000000\n891.000000\n891.000000\n891.000000\n\n\nmean\n446.000000\n0.383838\n2.308642\n29.699118\n0.523008\n0.381594\n32.204208\n\n\nstd\n257.353842\n0.486592\n0.836071\n14.526497\n1.102743\n0.806057\n49.693429\n\n\nmin\n1.000000\n0.000000\n1.000000\n0.420000\n0.000000\n0.000000\n0.000000\n\n\n25%\n223.500000\n0.000000\n2.000000\n20.125000\n0.000000\n0.000000\n7.910400\n\n\n50%\n446.000000\n0.000000\n3.000000\n28.000000\n0.000000\n0.000000\n14.454200\n\n\n75%\n668.500000\n1.000000\n3.000000\n38.000000\n1.000000\n0.000000\n31.000000\n\n\nmax\n891.000000\n1.000000\n3.000000\n80.000000\n8.000000\n6.000000\n512.329200\n\n\n\n\n\n\n\n\ntrain.describe(include='object')\n\n\n\n\n\n\n\n\nName\nSex\nTicket\nCabin\nEmbarked\n\n\n\n\ncount\n891\n891\n891\n204\n889\n\n\nunique\n891\n2\n681\n147\n3\n\n\ntop\nBraund, Mr. Owen Harris\nmale\n347082\nB96 B98\nS\n\n\nfreq\n1\n577\n7\n4\n644\n\n\n\n\n\n\n\n\nsns.countplot(train, x=\"Sex\", hue=\"Survived\")\nplt.title(\"Gender vs Survived\")\n\nText(0.5, 1.0, 'Gender vs Survived')\n\n\n\n\n\n\n\n\n\n\ntrain['logFare'] = train['Fare'].apply(np.log)\n\n\nsns.histplot(train, x=\"logFare\", hue=\"Survived\")\n\n\n\n\n\n\n\n\n\nsns.histplot(train, x=\"Age\", hue=\"Survived\")\n\n\n\n\n\n\n\n\n\nsns.countplot(train, x=\"Embarked\", hue=\"Survived\")\n\n\n\n\n\n\n\n\n\nsns.histplot(train, x=\"SibSp\", hue=\"Survived\")\n\n\n\n\n\n\n\n\n\nsns.histplot(train, x=\"Parch\", hue=\"Survived\")",
    "crumbs": [
      "misc",
      "Titanic Dataset prediction"
    ]
  },
  {
    "objectID": "misc/titanic-prediction.html#evals-and-metrics",
    "href": "misc/titanic-prediction.html#evals-and-metrics",
    "title": "Titanic Dataset prediction",
    "section": "Evals and metrics",
    "text": "Evals and metrics\n\ntrain, valid = train_test_split(train, test_size=0.2)\n\n\ndef evaluate(y_targets, y_preds, thresh=0.5):\n    # y_targets: classes 0/1\n    # y_preds: probs of being 1 (scores)\n    y_pred_labels = [1 if s&gt;=thresh else 0 for s in y_preds]\n    accuracy = accuracy_score(y_targets, y_pred_labels)\n    f1 = f1_score(y_targets, y_pred_labels)\n    loss = log_loss(y_targets, y_preds)\n    return accuracy, f1, loss",
    "crumbs": [
      "misc",
      "Titanic Dataset prediction"
    ]
  },
  {
    "objectID": "misc/titanic-prediction.html#random-model",
    "href": "misc/titanic-prediction.html#random-model",
    "title": "Titanic Dataset prediction",
    "section": "Random Model",
    "text": "Random Model\n\nrandom_model_accuracy, random_model_f1, random_model_loss = evaluate(valid[\"Survived\"].values, np.random.random_sample(len(valid)))\nprint(f\"{random_model_accuracy=} {random_model_f1=} {random_model_loss=}\")\n\nrandom_model_accuracy=0.5363128491620112 random_model_f1=0.4779874213836478 random_model_loss=0.8794932767664191",
    "crumbs": [
      "misc",
      "Titanic Dataset prediction"
    ]
  },
  {
    "objectID": "misc/titanic-prediction.html#feature-engg",
    "href": "misc/titanic-prediction.html#feature-engg",
    "title": "Titanic Dataset prediction",
    "section": "Feature Engg",
    "text": "Feature Engg\n\ndef feat_engg_pipeline(df, fillna=True):\n    x = deepcopy(df)\n    x = pd.concat([x, pd.get_dummies(x[\"Pclass\"], prefix=\"plcass\", dummy_na=True, drop_first=True)], axis=1)\n    x = pd.concat([x, pd.get_dummies(x[\"Embarked\"], prefix=\"embarked\", dummy_na=True, drop_first=True)], axis=1)\n    x = pd.concat([x, pd.get_dummies(x[\"Sex\"], prefix=\"sex\", dummy_na=True, drop_first=True)], axis=1)\n    x[\"logFare\"] = x[\"Fare\"].apply(lambda x: max(np.log(x), 0.0001))\n    x[\"SibSp\"] = x[\"SibSp\"].apply(lambda x: x if x&lt;2 else 2)\n    x[\"Parch\"] = x[\"Parch\"].apply(lambda x: x if x&lt;2 else 2)\n    x[\"age_isnan\"] = x[\"Age\"].apply(lambda x: x!=x)\n    x[\"Age\"] /= 100\n    x = x.fillna(0)\n    x = x.drop([\"Pclass\", \"Fare\", \"Name\", \"Embarked\", \"Ticket\", \"Cabin\", \"Sex\", \"PassengerId\", \"Survived\"], axis=1)\n    return x",
    "crumbs": [
      "misc",
      "Titanic Dataset prediction"
    ]
  },
  {
    "objectID": "misc/titanic-prediction.html#logistic-model",
    "href": "misc/titanic-prediction.html#logistic-model",
    "title": "Titanic Dataset prediction",
    "section": "Logistic Model",
    "text": "Logistic Model\n\nfrom sklearn.linear_model import LogisticRegression\n\n\nX = feat_engg_pipeline(train).to_numpy(float)\ny = train[\"Survived\"].values\n\n/var/folders/64/2d7m3w55173_15ss4212phx00000gn/T/ipykernel_79547/3317546291.py:6: RuntimeWarning: divide by zero encountered in log\n  x[\"logFare\"] = x[\"Fare\"].apply(lambda x: max(np.log(x), 0.0001))\n\n\n\nmodel = LogisticRegression()\nmodel.fit(X, y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.  LogisticRegression?Documentation for LogisticRegressioniFittedLogisticRegression() \n\n\n\nX_val, y_val = feat_engg_pipeline(valid).to_numpy(float), valid[\"Survived\"].values\n\n/var/folders/64/2d7m3w55173_15ss4212phx00000gn/T/ipykernel_79547/3317546291.py:6: RuntimeWarning: divide by zero encountered in log\n  x[\"logFare\"] = x[\"Fare\"].apply(lambda x: max(np.log(x), 0.0001))\n\n\n\ny_preds = model.predict_proba(X_val)[:, 1]\n\n\nevaluate(y_val, y_preds)\n\n(0.8268156424581006, 0.7832167832167832, 0.4435807485988586)",
    "crumbs": [
      "misc",
      "Titanic Dataset prediction"
    ]
  },
  {
    "objectID": "misc/k-means.html",
    "href": "misc/k-means.html",
    "title": "K-Means Implementation",
    "section": "",
    "text": "import numpy as np\nimport seaborn as sns\nimport pandas as pd\n\n\ndef generate_random_coordinates(num_points, x_range, y_range):\n    x_coords = np.random.uniform(x_range[0], x_range[1], num_points)\n    y_coords = np.random.uniform(y_range[0], y_range[1], num_points)\n    return np.column_stack((x_coords, y_coords))\n\n\npoints = []\nfor xr, yr in [[(0,1), (3,4)], [(2,1), (-1,-2)], [(3, 5), (3,5)]]:\n    points.extend(generate_random_coordinates(10, xr, yr).tolist())\n\n\ndf = pd.DataFrame(points, columns=['x','y'])\nsns.scatterplot(x='x', y='y', data=df)\n\n\n\n\n\n\n\n\n\nclass KMeans:\n\n    def __init__(self, k, max_iters=100):\n        self.k = k\n        self.max_iters = max_iters\n\n    def fit(self, points: np.array):\n        n, d = points.shape\n        \n        centroid_pts = points[np.random.randint(low=0, high=n, size=self.k)]\n        pts_to_centroid = [0]*n\n\n        for _ in range(self.max_iters):\n            for i in range(n):\n                pts_to_centroid[i] = self.get_closest_centroid(points[i], centroid_pts)\n    \n            for i in range(self.k):\n                cluster_points = [ix for ix, j in enumerate(pts_to_centroid) if j==i]\n                centroid_pts[i] = points[cluster_points].mean(axis=0)\n        return pts_to_centroid\n            \n    def get_closest_centroid(self, point, centroids):\n        d = float('inf')\n        r = 0\n        for j, cp in enumerate(centroids):\n            if self.distance(point, cp)&lt;d:\n                d = self.distance(point, cp)\n                r = j\n        return r\n    def distance(self, p1, p2): return np.linalg.norm(p1-p2)\n\n\ndf['cluster'] = KMeans(3).fit(df.to_numpy())\n\n\nsns.scatterplot(x='x', y='y', data=df, hue='cluster')",
    "crumbs": [
      "misc",
      "K-Means Implementation"
    ]
  },
  {
    "objectID": "misc/behavioral-questions.html",
    "href": "misc/behavioral-questions.html",
    "title": "Behavioral Questions",
    "section": "",
    "text": "Why do you want to work for X company?\nWhy do you want to leave your current/last company?\nWhat are you looking for in your next role?\nTell me about a time when you had a conflict with a co-worker.\nTell me about a time in which you had a conflict and needed to influence somebody else.\nWhat project are you currently working on?\nWhat is the most challenging aspect of your current project?\nWhat was the most difficult bug that you fixed in the past 6 months?\nHow do you tackle challenges? Name a difficult challenge you faced while working on a project, how you overcame it, and what you learned.\nWhat are you excited about?\nWhat frustrates you?\nImagine it is your first day here at the company. What do you want to work on? What features would you improve on?\nWhat are the most interesting projects you have worked on and how might they be relevant to this company’s environment?\nTell me about a time you had a disagreement with your manager.\nTalk about a project you are most passionate about, or one where you did your best work.\nWhat does your best day of work look like?\nWhat is something that you had to push for in your previous projects?\nWhat is the most constructive feedback you have received in your career?\nWhat is something you had to persevere at for multiple months?\nTell me about a time you met a tight deadline.\nIf this were your first annual review with our company, what would I be telling you right now?\nTime management has become a necessary factor in productivity. Give an example of a time-management skill you’ve learned and applied at work.\nTell me about a problem you’ve had getting along with a work associate.\nWhat aspects of your work are most often criticized?\nHow have you handled criticism of your work?\nWhat strengths do you think are most important for your job position?\nWhat words would your colleagues use to describe you?\nWhat would you hope to achieve in the first six months after being hired?\nTell me why you will be a good fit for the position.",
    "crumbs": [
      "misc",
      "Behavioral Questions"
    ]
  },
  {
    "objectID": "misc/behavioral-questions.html#questions",
    "href": "misc/behavioral-questions.html#questions",
    "title": "Behavioral Questions",
    "section": "",
    "text": "Why do you want to work for X company?\nWhy do you want to leave your current/last company?\nWhat are you looking for in your next role?\nTell me about a time when you had a conflict with a co-worker.\nTell me about a time in which you had a conflict and needed to influence somebody else.\nWhat project are you currently working on?\nWhat is the most challenging aspect of your current project?\nWhat was the most difficult bug that you fixed in the past 6 months?\nHow do you tackle challenges? Name a difficult challenge you faced while working on a project, how you overcame it, and what you learned.\nWhat are you excited about?\nWhat frustrates you?\nImagine it is your first day here at the company. What do you want to work on? What features would you improve on?\nWhat are the most interesting projects you have worked on and how might they be relevant to this company’s environment?\nTell me about a time you had a disagreement with your manager.\nTalk about a project you are most passionate about, or one where you did your best work.\nWhat does your best day of work look like?\nWhat is something that you had to push for in your previous projects?\nWhat is the most constructive feedback you have received in your career?\nWhat is something you had to persevere at for multiple months?\nTell me about a time you met a tight deadline.\nIf this were your first annual review with our company, what would I be telling you right now?\nTime management has become a necessary factor in productivity. Give an example of a time-management skill you’ve learned and applied at work.\nTell me about a problem you’ve had getting along with a work associate.\nWhat aspects of your work are most often criticized?\nHow have you handled criticism of your work?\nWhat strengths do you think are most important for your job position?\nWhat words would your colleagues use to describe you?\nWhat would you hope to achieve in the first six months after being hired?\nTell me why you will be a good fit for the position.",
    "crumbs": [
      "misc",
      "Behavioral Questions"
    ]
  },
  {
    "objectID": "misc/behavioral-questions.html#questions-to-ask-the-interviewer",
    "href": "misc/behavioral-questions.html#questions-to-ask-the-interviewer",
    "title": "Behavioral Questions",
    "section": "Questions to ask the interviewer",
    "text": "Questions to ask the interviewer\n\nWhat sort of tangible changes has this organization made in regards to promoting gender diversity?\nWhat are the most exciting projects you’ve worked on here?\nWhat do you like most about the organization?\nWhat would you change about the organization?\nHow has the organization changed since you’ve joined?\nWhat do you like most about working here?\nCan you describe the organization’s overall management style and the type of person who usually does well here?\nWhat excites you the most about the organization’s future?\nIf you could change one thing about the organization, what would it be?\nDoes the organization have any traditions or rituals that you like?\nWhere do you see the organization in three years and how would I contribute to that if I’m hired for this role?\nWhat is a challenge the organization is facing right now and how could I contribute to overcoming it?\nIn what ways might this role change in the next year?\nWhat would the onboarding process be like for this role?\nWhat can you tell me about the position that isn’t in the job description?\nDo you expect to do more hiring in this group in the next six months?\nWhat surprised you about the organization after you started working here?\nWhat has allowed you to be successful here?\nHow does the organization respond to failure?\nTell me about your most successful employees. What do they do that really sets them apart?\nWhat haven’t I asked about that most candidates want to know?\nIf you were interviewing with your organization again, what questions would you be asking?\n(If this is your future boss) How would you describe your management style?\nWhat’s your timeline for the next steps?\nAre there resources I could review in advance to get a head start on the learning curve?",
    "crumbs": [
      "misc",
      "Behavioral Questions"
    ]
  },
  {
    "objectID": "misc/classify-tweets.html",
    "href": "misc/classify-tweets.html",
    "title": "Tweet Classification",
    "section": "",
    "text": "! pip install -U kaggle transformers pandas tqdm scikit-learn numpy --quiet\n\n\nimport pandas as pd\nfrom tqdm import tqdm\nfrom tqdm import tqdm_notebook\nfrom transformers import AutoTokenizer\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.decomposition import PCA\nfrom sklearn.metrics import RocCurveDisplay, roc_curve, accuracy_score, confusion_matrix, f1_score\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.pipeline import Pipeline as MLPipeline\nfrom sklearn.model_selection import train_test_split\nfrom fastai.imports import *\nimport kaggle\nnp.set_printoptions(linewidth=130)\n\ntqdm.pandas()\n\n\npath = Path(\"/tmp/\")\nkaggle.api.dataset_download_cli(\"ashwiniyer176/toxic-tweets-dataset\", force=True, path=path)\n! unzip {path / \"toxic-tweets-dataset.zip\"}\n\nDataset URL: https://www.kaggle.com/datasets/ashwiniyer176/toxic-tweets-dataset\nLicense(s): unknown\nDownloading toxic-tweets-dataset.zip to /tmp\n\nArchive:  /tmp/toxic-tweets-dataset.zip\n  inflating: FinalBalancedDataset.csv  \n\n\n100%|██████████| 2.21M/2.21M [00:00&lt;00:00, 13.6MB/s]\n\n\n\ndf = pd.read_csv(Path(\".\") / \"FinalBalancedDataset.csv\")\n! rm {Path(\".\") / \"FinalBalancedDataset.csv\"}\ndf = df.drop(\"Unnamed: 0\", axis=1)\ndf.head(2)\n\n\n\n\n\n\n\n\nToxicity\ntweet\n\n\n\n\n0\n0\n@user when a father is dysfunctional and is so selfish he drags his kids into his dysfunction. #run\n\n\n1\n0\n@user @user thanks for #lyft credit i can't use cause they don't offer wheelchair vans in pdx. #disapointed #getthanked\n\n\n\n\n\n\n\n\ndf.Toxicity.value_counts()\n\nToxicity\n0    32592\n1    24153\nName: count, dtype: int64\n\n\n\ndf.loc[df.Toxicity==1, :].head(2)\n\n\n\n\n\n\n\n\nToxicity\ntweet\n\n\n\n\n13\n1\n@user #cnn calls #michigan middle school 'build the wall' chant '' #tcot\n\n\n14\n1\nno comment! in #australia #opkillingbay #seashepherd #helpcovedolphins #thecove #helpcovedolphins\n\n\n\n\n\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"bert-base-uncased\")\n\n\ntokenizer.vocab_size\n\n30522\n\n\n\ndef tokenizefn(s): return tokenizer.tokenize(s)\n\n\nX, y = list(df.tweet.values.tolist()), df.Toxicity.values.tolist()\n\n\nx_train, x_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2)\n\n\nlen(x_train), len(x_valid), len(y_train), len(y_valid)\n\n(45396, 11349, 45396, 11349)\n\n\n\ntfidf = TfidfVectorizer(tokenizer=tokenizefn, vocabulary=tokenizer.vocab, lowercase=False)\n# pca = PCA(n_components=512)\nsvd = TruncatedSVD(n_components=512)\nrf = RandomForestClassifier()\nmodel = MLPipeline(\n    [('tfidf', tfidf), \n     # ('pca', pca), \n     ('svd',svd),\n     ('rf', rf)])\n\n\nmodel.fit(x_train, y_train)\n\n/Users/akhilvempali/miniconda3/envs/ml/lib/python3.9/site-packages/sklearn/feature_extraction/text.py:523: UserWarning: The parameter 'token_pattern' will not be used since 'tokenizer' is not None'\n  warnings.warn(\n\n\n\ny_preds = model.predict_proba(x_valid)\n\n\ny_preds = y_preds[:, 1]\n\n\nfpr, tpr, _ = roc_curve(y_valid, y_preds, pos_label=model.classes_[1])\n\n\nroc_display = RocCurveDisplay(fpr=fpr, tpr=tpr).plot()\n\n/Users/akhilvempali/miniconda3/envs/ml/lib/python3.9/site-packages/sklearn/metrics/_plot/roc_curve.py:171: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  self.ax_.legend(loc=\"lower right\")\n\n\n\n\n\n\n\n\n\n\nthresh = 0.5\nlabels = [1 if x&gt;thresh else 0 for x in y_preds]\naccuracy = accuracy_score(y_valid, labels)\nf1 = f1_score(y_valid, labels)\nprint(f\"{accuracy=}, {f1=}\")\n\naccuracy=0.9026345933562429, f1=0.8806824317028399\n\n\n\nconfusion_matrix(y_valid, labels)\n\narray([[6166,  460],\n       [ 645, 4078]])",
    "crumbs": [
      "misc",
      "Tweet Classification"
    ]
  },
  {
    "objectID": "makemore/bigram.html",
    "href": "makemore/bigram.html",
    "title": "Bigram Model",
    "section": "",
    "text": "from huggingface_hub import notebook_login\nimport torch\nfrom transformers import AutoTokenizer\nimport matplotlib.pyplot as plt\nimport random\nfrom fastcore.all import *",
    "crumbs": [
      "makemore",
      "Bigram Model"
    ]
  },
  {
    "objectID": "makemore/bigram.html#dataset-generation",
    "href": "makemore/bigram.html#dataset-generation",
    "title": "Bigram Model",
    "section": "Dataset generation",
    "text": "Dataset generation\n\nnames = urlopen(\"https://raw.githubusercontent.com/FinNLP/cities-list/master/list.txt\").read().decode(\"utf-8\").splitlines()\nnames = [\".\"+s.lower()+\".\" for s in names]\n\n\nnames[:10]\n\n['.aabenraa.',\n '.aach.',\n '.aachen.',\n '.aadorf.',\n '.aalborg.',\n '.aalburg.',\n '.aalen.',\n '.aalsmeer.',\n '.aalst.',\n '.aalten.']",
    "crumbs": [
      "makemore",
      "Bigram Model"
    ]
  },
  {
    "objectID": "makemore/bigram.html#training-of-bigram-model",
    "href": "makemore/bigram.html#training-of-bigram-model",
    "title": "Bigram Model",
    "section": "Training of bigram model",
    "text": "Training of bigram model\n\nvocab = \"abcdefghijklmnopqrstuvwxyz.\"\nvocab_size = len(vocab)\ndef tok_fn(s: str): return list(c for c in s)\ntok2id = dict((c,i) for i, c in enumerate(vocab))\nid2tok = dict((i,c) for i, c in enumerate(vocab))\n\n\nnames = [name for name in names if all(c in vocab for c in name)]\n\n\nmat = torch.zeros((vocab_size, vocab_size), dtype=torch.int32)\n\n\nfor name in names:\n    for c, nc in zip(name, name[1:]): mat[tok2id[c]][tok2id[nc]] += 1\n\n\nplt.figure(figsize=(16, 20))\nplt.imshow(mat, cmap=\"Blues\")\nfor i in range(vocab_size):\n    for j in range(vocab_size):\n        ch_str =  id2tok[i]+id2tok[j]\n        plt.text(j, i, mat[i][j].item(), color=\"gray\", ha=\"center\", va=\"bottom\")\n        plt.text(j, i, ch_str, color=\"gray\", ha=\"center\", va=\"top\")\nplt.axis(\"off\")\n\n\n\n\n\n\n\n\nConverting frequencies of the bigrams to probabilities. For each given char c we have an array of frequencies of the chars following it. We can convert this to a probability distribution where this array is converted to a distribution which tells whats the next most likely char given this char.\n\nN = mat + 1 # model smoothing\nprobs = N / N.sum(1, keepdim=True)\ni = 10\nplt.ylim(0, 0.3)\nplt.plot(probs[i])\nplt.title(f\"{id2tok[i]=}\")\n\nText(0.5, 1.0, \"id2tok[i]='k'\")",
    "crumbs": [
      "makemore",
      "Bigram Model"
    ]
  },
  {
    "objectID": "makemore/bigram.html#bi-gram-model",
    "href": "makemore/bigram.html#bi-gram-model",
    "title": "Bigram Model",
    "section": "Bi-Gram Model",
    "text": "Bi-Gram Model\n\ng = torch.Generator().manual_seed(42)\nfor _ in range(20):\n    i = tok2id[\".\"]\n    w = \"\"\n    while True:\n        w += id2tok[i]\n        i = torch.multinomial(probs[i], num_samples=1, replacement=True, generator=g).item()\n        if id2tok[i]==\".\": break\n    print(w[1:])\n\nbavienowiltanbajevagyontroonthmarier\npuntidenamoa\nbaddovethant\ndaloydonglowa\nheveraanorirzkhilawaijinia\nbaloru\nbenarik\nbar\npudia\nferyatehisinciav\nmo\ndworanaseterssan\nkashyaminkonnagi\nldesenoimon\nhalagl\nvidicharbupesackir\nk\nerauneller\nbrra\nnesikamutrumbalelng",
    "crumbs": [
      "makemore",
      "Bigram Model"
    ]
  },
  {
    "objectID": "makemore/bigram.html#random-model",
    "href": "makemore/bigram.html#random-model",
    "title": "Bigram Model",
    "section": "Random Model",
    "text": "Random Model\n\ng = torch.Generator().manual_seed(42)\nfor _ in range(20):\n    i = tok2id[\".\"]\n    w = \"\"\n    while True:\n        w += id2tok[i]\n        i = torch.multinomial(torch.ones(vocab_size), num_samples=1, replacement=True, generator=g).item()\n        if id2tok[i]==\".\": break\n    print(w[1:])\n\nykvhvfpwuqtagbcjrvfeygnvcoxntgmbzqhh\npgnxixmypmoafqkddvpethken\nvayoydnkkpceshhcemmlanorirzkgcidwhijhfbd\nbmdwkxjbkxuqikqenrtpuddaxfmryptwhlpdpcsavlmoodwsjhnzeztpvngaqkkjfxyaminkvinagtdlcjsepwihoalhplugl\nvbdbcqbabupesacyxrmkderaunebnqf\nbrkapnubgkjjswrumglzfvnyvp\nubnfarw\nrnzjphabdeurvnlpswezyyimtphpcauotmxlhnogvzddrfoeimoarvfifkpkjjgejsoechdqwstd\nbhsuqmardakcorueb\nrzhljiiozowzgkg\nhymwlrodrhbixljha\nooitwjmhauazgotdyiidlrzhqbjbihegkhahx\nkeqjjugqmemfszhlyqvxgpaexoiggyzzvwhncutdf\nerrdaa\nlaqjeiuerguym\npmwiygfqhrclpufnxjjjopxfqubeyumrywuafxwfsasgjkboyncqxmgikonotlhgmjfqlkezxurmwhvlinkxpdaqcsbuuqfssu\nz\npksbfshabhtroifdugmrqdat\ntjk\nqvdwkclgquyks",
    "crumbs": [
      "makemore",
      "Bigram Model"
    ]
  },
  {
    "objectID": "makemore/bigram.html#model-analysis",
    "href": "makemore/bigram.html#model-analysis",
    "title": "Bigram Model",
    "section": "Model Analysis",
    "text": "Model Analysis\nTo calculate how good the model performs on a dataset, we can calculate its output probs on the dataset. How confident is the model in predicting the next token of the dataset? An ideal model could predict the with high probability the dataset, if it is trained from the same distribution. A bad model, will be less confident in predicting the dataset. Lets identify the model quality for the training data\n\nfor w in names[:3]:\n    for c, nc in zip(w, w[1:]):\n        p = probs[tok2id[c], tok2id[nc]]\n        print(f\"{c}{nc} {p=:.4f}\")\n\n.a p=0.0568\naa p=0.0049\nab p=0.0225\nbe p=0.1822\nen p=0.1498\nnr p=0.0027\nra p=0.1623\naa p=0.0049\na. p=0.1688\n.a p=0.0568\naa p=0.0049\nac p=0.0344\nch p=0.2913\nh. p=0.1039\n.a p=0.0568\naa p=0.0049\nac p=0.0344\nch p=0.2913\nhe p=0.1649\nen p=0.1498\nn. p=0.2224\n\n\nIf it were a random model, all the bigram probs would have been 1/27==0.0370. However here a few bigrams have much higher probability than that, showing that this model has captured some information. We can summarise in a single number, by aggregating the model outputted probs for the dataset by multiplying all probs together. This is called the likelihood. Since all 0 &lt;  values &lt; 1 we take log of the values, and get log-likelihood, and just take negative of this value to get negative likelihood. This negative likelihood has the characterstic of decreasing with increasing model quality, which is semantically similar to loss of a model.\n\ncnts = 0\nneg_log_likelihood_bigram_model = 0.\nneg_log_likelihood_random_model = 0.\nfor w in names:\n    for c, nc in zip(w, w[1:]):\n        p = probs[tok2id[c], tok2id[nc]]\n        nll = -torch.log(p).item()\n        neg_log_likelihood_bigram_model += nll\n        neg_log_likelihood_random_model += -torch.log(torch.tensor(1/27)).item()\n        if cnts&lt;10: print(f\"{c}{nc} {p=:.4f}, {nll=:.4f}\")\n        cnts += 1\nprint(f\"\\n{neg_log_likelihood_bigram_model=:.4f}\\n{neg_log_likelihood_random_model=:.4f}\")\n\n.a p=0.0568, nll=2.8679\naa p=0.0049, nll=5.3218\nab p=0.0225, nll=3.7933\nbe p=0.1822, nll=1.7029\nen p=0.1498, nll=1.8985\nnr p=0.0027, nll=5.8981\nra p=0.1623, nll=1.8186\naa p=0.0049, nll=5.3218\na. p=0.1688, nll=1.7790\n.a p=0.0568, nll=2.8679\n\nneg_log_likelihood_bigram_model=1330956.0329\nneg_log_likelihood_random_model=1669209.5693\n\n\nDuring model development, our main goal would be to beat this number abnd create a model that has a lower negative log likelihood. In practice, we can also use average negative log likelihood. Which would just be\n\nprint(f\"{neg_log_likelihood_bigram_model/cnts=:.4f}\\n{neg_log_likelihood_random_model/cnts=:.4f}\")\n\nneg_log_likelihood_bigram_model/cnts=2.6280\nneg_log_likelihood_random_model/cnts=3.2958\n\n\nThis does’nt always need to be calculated for the entire dataset, we can even check this at inference time. In that case, it would mean that for a random name, how likely would the model have generated the name?\n\nrandom_name = \"toronto\"\nrandom_name = \".\"+random_name+\".\"\nn, nll_bigram_model, nll_random_model = 0, 0., 0.\nfor c, nc in zip(random_name, random_name[1:]):\n    prob = probs[tok2id[c], tok2id[nc]]\n    nll_random_model += -torch.log(torch.tensor(1/27)).item()\n    nll_bigram_model += -torch.log(prob).item()\n    n += 1\nprint(f\"\\n{nll_bigram_model/n=:.4f}\\n{nll_random_model/n=:.4f}\")\n\n\nnll_bigram_model/n=2.2143\nnll_random_model/n=3.2958",
    "crumbs": [
      "makemore",
      "Bigram Model"
    ]
  },
  {
    "objectID": "misc/product-sense-case-study-framework.html",
    "href": "misc/product-sense-case-study-framework.html",
    "title": "Product Sense Case Study Frameworks",
    "section": "",
    "text": "Typically you would be given a metric / KPI that is not performing as expected. You would then need to diagnose the problem.\n\nClarify the metric / KPI\n\nWhat does the metric measure?\nHow is it measured?\nWhat is the frequency of measurement?\n\nTemporal analysis\n\nHow has the metric been performing over time?\n\nweek-on-week\nyear-on-year\n\nAre there any trends?\n\nindustry trend?\nseasonality?\n\nexternal factors?\n\nchange by competition\ndrastic change in environment\n\n\nProduct related or company related change\n\nany change in product or feature?\nany change in company policy?\nchange in competitors product?\n\nDemographic / geographic / behavioral analysis\n\nisolate based on region / location\nsegment by language\nplatforms\n\nandroid vs ios vs web\nmobile vs desktop\n\n\nDecompose metric\n\nis metric a composite of other metrics?\nis the mteric predicted?",
    "crumbs": [
      "misc",
      "Product Sense Case Study Frameworks"
    ]
  },
  {
    "objectID": "misc/product-sense-case-study-framework.html#diagnose-a-problem",
    "href": "misc/product-sense-case-study-framework.html#diagnose-a-problem",
    "title": "Product Sense Case Study Frameworks",
    "section": "",
    "text": "Typically you would be given a metric / KPI that is not performing as expected. You would then need to diagnose the problem.\n\nClarify the metric / KPI\n\nWhat does the metric measure?\nHow is it measured?\nWhat is the frequency of measurement?\n\nTemporal analysis\n\nHow has the metric been performing over time?\n\nweek-on-week\nyear-on-year\n\nAre there any trends?\n\nindustry trend?\nseasonality?\n\nexternal factors?\n\nchange by competition\ndrastic change in environment\n\n\nProduct related or company related change\n\nany change in product or feature?\nany change in company policy?\nchange in competitors product?\n\nDemographic / geographic / behavioral analysis\n\nisolate based on region / location\nsegment by language\nplatforms\n\nandroid vs ios vs web\nmobile vs desktop\n\n\nDecompose metric\n\nis metric a composite of other metrics?\nis the mteric predicted?",
    "crumbs": [
      "misc",
      "Product Sense Case Study Frameworks"
    ]
  },
  {
    "objectID": "misc/product-sense-case-study-framework.html#measure-success-of-product-feature",
    "href": "misc/product-sense-case-study-framework.html#measure-success-of-product-feature",
    "title": "Product Sense Case Study Frameworks",
    "section": "Measure Success of product / feature",
    "text": "Measure Success of product / feature\n\nclarify the function or goal of the product / feature\n\nwhat does the product do?\nHow is it used?\nWho is it for?\n\ndefine metric\n\nsuccess metric\nguardrail metric\nshould fit context",
    "crumbs": [
      "misc",
      "Product Sense Case Study Frameworks"
    ]
  },
  {
    "objectID": "misc/product-sense-case-study-framework.html#launch-or-not",
    "href": "misc/product-sense-case-study-framework.html#launch-or-not",
    "title": "Product Sense Case Study Frameworks",
    "section": "Launch or not",
    "text": "Launch or not\n\nclarify the goal and define metric\n\nask question to clarify goal\ndefine a success metric\ndefine a guardrail metric\n\nexperimentation\n\nhow to design the A/B test\nhow to split the users\nHow long to run it?\n\nrecommendation\n\nconflicting results",
    "crumbs": [
      "misc",
      "Product Sense Case Study Frameworks"
    ]
  },
  {
    "objectID": "misc/dictionary-learning.html",
    "href": "misc/dictionary-learning.html",
    "title": "Dictionary Learning",
    "section": "",
    "text": "from sklearn.decomposition import DictionaryLearning\nfrom sklearn.datasets import fetch_olivetti_faces\nimport matplotlib.pyplot as plt\nimport random\nimport numpy as np\n\n\nfaces = fetch_olivetti_faces(shuffle=True, random_state=42)\n\n\nplt.figure(figsize=(10, 7))\nfor i, face in enumerate(random.choices(faces.images, k=9)):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(face, cmap=\"gray\")\n    plt.xticks(())\n    plt.yticks(())",
    "crumbs": [
      "misc",
      "Dictionary Learning"
    ]
  },
  {
    "objectID": "misc/dictionary-learning.html#collect-faces-data",
    "href": "misc/dictionary-learning.html#collect-faces-data",
    "title": "Dictionary Learning",
    "section": "",
    "text": "from sklearn.decomposition import DictionaryLearning\nfrom sklearn.datasets import fetch_olivetti_faces\nimport matplotlib.pyplot as plt\nimport random\nimport numpy as np\n\n\nfaces = fetch_olivetti_faces(shuffle=True, random_state=42)\n\n\nplt.figure(figsize=(10, 7))\nfor i, face in enumerate(random.choices(faces.images, k=9)):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(face, cmap=\"gray\")\n    plt.xticks(())\n    plt.yticks(())",
    "crumbs": [
      "misc",
      "Dictionary Learning"
    ]
  },
  {
    "objectID": "misc/dictionary-learning.html#create-a-dl-model",
    "href": "misc/dictionary-learning.html#create-a-dl-model",
    "title": "Dictionary Learning",
    "section": "Create a DL Model",
    "text": "Create a DL Model\n\nnum_samples, m1, m2 = faces.images.shape\n\n\nX = faces.images.reshape((num_samples, -1))\n\n\nn_atoms = 64\nn_iter = 30\ndl_model = DictionaryLearning(n_components=n_atoms, alpha=1.8, max_iter=n_iter)\ndl_model.fit(X)\n\nDictionaryLearning(alpha=1.8, max_iter=30, n_components=64)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.DictionaryLearningDictionaryLearning(alpha=1.8, max_iter=30, n_components=64)\n\n\n\ndictionary = dl_model.components_\nsparse_codes = dl_model.transform(X)\n\n/Users/akhilvempali/miniconda3/envs/ml/lib/python3.9/site-packages/sklearn/decomposition/_dict_learning.py:193: RuntimeWarning: Orthogonal matching pursuit ended prematurely due to linear dependence in the dictionary. The requested precision might not have been met.\n  new_code = orthogonal_mp_gram(",
    "crumbs": [
      "misc",
      "Dictionary Learning"
    ]
  },
  {
    "objectID": "misc/dictionary-learning.html#observations",
    "href": "misc/dictionary-learning.html#observations",
    "title": "Dictionary Learning",
    "section": "Observations",
    "text": "Observations\n\nDictionary\nLearnt dictionary\n\nplt.figure(figsize=(8, 8))\nfor i in range(n_atoms):\n    plt.subplot(8, 8, i + 1)\n    plt.imshow(dictionary[i].reshape((64, 64)), cmap=plt.cm.gray, interpolation='nearest')\n    plt.xticks(())\n    plt.yticks(())\n\n\n\n\n\n\n\n\n\n\nFor any 1 picture, activations of different atoms\n\nplt.figure(figsize=(10, 5))\nn_faces_to_plot = 1\nfor i in range(n_faces_to_plot):\n    plt.subplot(n_faces_to_plot, 2, i * 2 + 1)\n    plt.imshow(faces.images[i], cmap=plt.cm.gray, interpolation='nearest')\n    plt.title('Original Face')\n    plt.xticks(())\n    plt.yticks(())\n    \n    plt.subplot(n_faces_to_plot, 2, i * 2 + 2)\n    plt.stem(sparse_codes[i])\n    plt.title('Sparse Representation')\n    plt.xlabel('Dictionary Atom Index')\n    plt.ylabel('Coefficient Value')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nFor any random atom, samples which have highest activation as that atom\n\nmost_activated_atoms_for_each_face = np.argmax(sparse_codes, axis=1)\nrand_atom = 4\nixs = [i for i, a in enumerate(most_activated_atoms_for_each_face) if a==rand_atom]\nprint(f\"{rand_atom=} and faces with most active atom as rand_atom {ixs=}\")\n\nrand_atom=4 and faces with most active atom as rand_atom ixs=[7, 89, 173, 176, 269, 288, 343, 346]\n\n\n\nplt.figure(figsize=(10, 5))\nplt.title(f'Images with highest atom activation at atom : {rand_atom}')\nplt.xticks(()); plt.yticks(())\nfor i, im_ix in enumerate(ixs[:9]):\n    plt.subplot(3, 3, i+1)\n    plt.imshow(faces.images[im_ix], cmap=\"gray\")\n    plt.xticks(()); plt.yticks(())",
    "crumbs": [
      "misc",
      "Dictionary Learning"
    ]
  },
  {
    "objectID": "misc/resources.html",
    "href": "misc/resources.html",
    "title": "Resources to refer",
    "section": "",
    "text": "How to Crack Machine learning Interviews at FAANG!\nYuan Meng ML Interview Prep\nML Cheatsheet\nML Interview Questions\nIllustrated Transformer",
    "crumbs": [
      "misc",
      "Resources to refer"
    ]
  },
  {
    "objectID": "misc/resources.html#blogs-to-read",
    "href": "misc/resources.html#blogs-to-read",
    "title": "Resources to refer",
    "section": "",
    "text": "How to Crack Machine learning Interviews at FAANG!\nYuan Meng ML Interview Prep\nML Cheatsheet\nML Interview Questions\nIllustrated Transformer",
    "crumbs": [
      "misc",
      "Resources to refer"
    ]
  },
  {
    "objectID": "misc/resources.html#video-series-to-watch",
    "href": "misc/resources.html#video-series-to-watch",
    "title": "Resources to refer",
    "section": "Video Series to watch",
    "text": "Video Series to watch\n\nStatquest Machine Learning\nStatquest Statistics (for statistics review - most useful for Data Science roles)\nBharthi Priya’s Playlist\nStructuring Machine Learning Projects",
    "crumbs": [
      "misc",
      "Resources to refer"
    ]
  },
  {
    "objectID": "misc/resources.html#coding-resources",
    "href": "misc/resources.html#coding-resources",
    "title": "Resources to refer",
    "section": "Coding Resources",
    "text": "Coding Resources\n\nGraphs\nML Questions",
    "crumbs": [
      "misc",
      "Resources to refer"
    ]
  },
  {
    "objectID": "misc/resources.html#general-resources-for-nlp",
    "href": "misc/resources.html#general-resources-for-nlp",
    "title": "Resources to refer",
    "section": "General resources for NLP",
    "text": "General resources for NLP\n\nhttps://nlpprogress.com/",
    "crumbs": [
      "misc",
      "Resources to refer"
    ]
  },
  {
    "objectID": "misc/resources.html#behavioral-questions",
    "href": "misc/resources.html#behavioral-questions",
    "title": "Resources to refer",
    "section": "Behavioral Questions",
    "text": "Behavioral Questions\n\nblog",
    "crumbs": [
      "misc",
      "Resources to refer"
    ]
  },
  {
    "objectID": "misc/experience-notes.html",
    "href": "misc/experience-notes.html",
    "title": "Experience Notes",
    "section": "",
    "text": "confusion matrix\n\n\n\nFor Intent Classification, we measure first coverage which is number of cases correctly classified divided by the total number of cases “classified”. In the above matric this is equivalent to recall.\nFor measuring how many cases got correctly classified, we use accuracy which is the number of cases correctly classified divided by the total actual cases. This is equivalent to precision in the above matrix.\nWe also look at miss-classification rate, that is out of the total predicted classes how many were miss-classified.\nOut-of-Scope Accuracy is the total out-of-scope predicted cases divided by the total actual out-of-scope cases.",
    "crumbs": [
      "misc",
      "Experience Notes"
    ]
  },
  {
    "objectID": "misc/experience-notes.html#accuracy-coverage-out-of-scope-accuracy",
    "href": "misc/experience-notes.html#accuracy-coverage-out-of-scope-accuracy",
    "title": "Experience Notes",
    "section": "",
    "text": "confusion matrix\n\n\n\nFor Intent Classification, we measure first coverage which is number of cases correctly classified divided by the total number of cases “classified”. In the above matric this is equivalent to recall.\nFor measuring how many cases got correctly classified, we use accuracy which is the number of cases correctly classified divided by the total actual cases. This is equivalent to precision in the above matrix.\nWe also look at miss-classification rate, that is out of the total predicted classes how many were miss-classified.\nOut-of-Scope Accuracy is the total out-of-scope predicted cases divided by the total actual out-of-scope cases.",
    "crumbs": [
      "misc",
      "Experience Notes"
    ]
  },
  {
    "objectID": "basics/ml-models.html",
    "href": "basics/ml-models.html",
    "title": "ML Models",
    "section": "",
    "text": "This model tries to find the best line that fits the data. The line is defined by the equation y = mx + b, where m is the slope of the line and b is the y-intercept. The model tries to find the best values for m and b that minimize the error between the predicted values and the actual values. Usually we use OLS (Ordinary Least Squares) to find the best values for m and b.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#linear-regression",
    "href": "basics/ml-models.html#linear-regression",
    "title": "ML Models",
    "section": "",
    "text": "This model tries to find the best line that fits the data. The line is defined by the equation y = mx + b, where m is the slope of the line and b is the y-intercept. The model tries to find the best values for m and b that minimize the error between the predicted values and the actual values. Usually we use OLS (Ordinary Least Squares) to find the best values for m and b.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#svm",
    "href": "basics/ml-models.html#svm",
    "title": "ML Models",
    "section": "SVM",
    "text": "SVM\nIn this model we try to find the best hyperplane that separates the data into two classes. The hyperplane is defined by the equation w^T * x + b = 0, where w is the normal vector to the hyperplane and b is the bias. The model tries to find the best values for w and b that maximize the margin between the two classes. If the data is not linearly separable, we can use the kernel trick to transform the data into a higher dimensional space where it is linearly separable. Kernel functions can be linear, polynomial, radial basis function (RBF).",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#neural-networks",
    "href": "basics/ml-models.html#neural-networks",
    "title": "ML Models",
    "section": "Neural Networks",
    "text": "Neural Networks\nThis model is inspired by the human brain. It consists of layers of neurons that are connected to each other. Each neuron receives some input, applies an activation function to it, and passes the output to the next layer. The model tries to find the best weights for the connections between the neurons that minimize the error between the predicted values and the actual values. We can have different architectures for neural networks, such as feedforward, convolutional, recurrent, etc.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#naive-bayes-classifier",
    "href": "basics/ml-models.html#naive-bayes-classifier",
    "title": "ML Models",
    "section": "Naive Bayes Classifier",
    "text": "Naive Bayes Classifier\nThis model is based on Bayes’ theorem. It assumes that the features are independent of each other. The model calculates the probability of each class given the features and selects the class with the highest probability. We can have different types of Naive Bayes classifiers, such as Gaussian, Multinomial, Bernoulli. More formally, the model calculates the probability of each class given the features using the formula: \\(P(class|features) = P(class) * P(features|class) / P(features)\\). We select the class with the highest probability.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#logistic-regression",
    "href": "basics/ml-models.html#logistic-regression",
    "title": "ML Models",
    "section": "Logistic Regression",
    "text": "Logistic Regression\nThis model is used for binary classification problems. It tries to find the best line that separates the data into two classes. The line is defined by the equation y = mx + b, where m is the slope of the line and b is the y-intercept. The model applies the sigmoid function to the output of the line to get the probability of the positive class. The model tries to find the best values for m and b that maximize the likelihood of the data. Formula for sigmoid function:\n\\(f(x) = 1 / (1 + e^{-x})\\).",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#k-nearest-neighbors",
    "href": "basics/ml-models.html#k-nearest-neighbors",
    "title": "ML Models",
    "section": "K-Nearest Neighbors",
    "text": "K-Nearest Neighbors\nThis model is based on the idea that similar data points tend to be close to each other. The model stores all the data points and their labels in memory. When we want to make a prediction for a new data point, the model finds the k nearest neighbors to the new data point and selects the majority class among them. We can use different distance metrics to find the nearest neighbors, such as Euclidean, Manhattan, Minkowski, etc.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#decision-trees",
    "href": "basics/ml-models.html#decision-trees",
    "title": "ML Models",
    "section": "Decision Trees",
    "text": "Decision Trees\nThis model is based on a tree-like structure where each node represents a feature, each branch represents a decision based on that feature, and each leaf node represents the outcome. The model tries to find the best feature and the best value for that feature that splits the data into two classes. We can use different criteria to measure the impurity of the data, such as Gini impurity, entropy, misclassification error. The model keeps splitting the data until it reaches a stopping criterion, such as maximum depth, minimum samples per leaf, etc.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#random-forest",
    "href": "basics/ml-models.html#random-forest",
    "title": "ML Models",
    "section": "Random Forest",
    "text": "Random Forest\nThis model is an ensemble of decision trees. It creates multiple decision trees using random subsets of the data and random subsets of the features. Each tree makes a prediction, and the final prediction is the majority vote among all the trees. This helps to reduce overfitting and improve the generalization of the model. We can use different criteria to measure the impurity of the data, Gini impurity, entropy, misclassification error.\nFormula for Gini impurity:\n\\(Gini = 1 - \\sum_{i=1}^{n} p_i^2\\). where \\(p_i\\) is the probability of class i.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#gradient-boosting",
    "href": "basics/ml-models.html#gradient-boosting",
    "title": "ML Models",
    "section": "Gradient Boosting",
    "text": "Gradient Boosting\nThis model is an ensemble of weak learners, usually decision trees. It creates multiple decision trees sequentially, where each tree tries to correct the errors made by the previous trees. The model combines the predictions of all the trees to make the final prediction. We can use different loss functions to measure the error, such as squared error, absolute error, etc. We can use different boosting algorithms, such as AdaBoost, Gradient Boosting, XGBoost, LightGBM, CatBoost.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#k-means",
    "href": "basics/ml-models.html#k-means",
    "title": "ML Models",
    "section": "K-Means",
    "text": "K-Means\nThis model is used for clustering problems. It tries to find k clusters in the data. The model initializes k centroids randomly and assigns each data point to the nearest centroid. Then it updates the centroids by taking the mean of all the data points assigned to that centroid. The model repeats this process until the centroids do not change significantly. We can use different distance metrics to find the nearest centroid, such as Euclidean, Manhattan, Minkowski, etc.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#dbscan",
    "href": "basics/ml-models.html#dbscan",
    "title": "ML Models",
    "section": "DBSCAN",
    "text": "DBSCAN\nThis model is used for clustering problems. It tries to find clusters of arbitrary shapes in the data. The model takes two parameters, epsilon and min_samples. It starts with a random data point and finds all the data points within epsilon distance from it. If the number of data points is greater than min_samples, it forms a cluster. Then it expands the cluster by finding all the data points within epsilon distance from the border points. The model repeats this process until all the data points are assigned to a cluster.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/ml-models.html#pca",
    "href": "basics/ml-models.html#pca",
    "title": "ML Models",
    "section": "PCA",
    "text": "PCA\nThis model is used for dimensionality reduction. It tries to find the principal components of the data, which are the directions along which the data varies the most. The model projects the data onto the principal components, reducing the dimensionality of the data. We can select the number of principal components based on the amount of variance we want to retain in the data. The model can be used for visualization, noise reduction, feature extraction, etc.",
    "crumbs": [
      "basics",
      "ML Models"
    ]
  },
  {
    "objectID": "basics/time-complexity-analysis.html",
    "href": "basics/time-complexity-analysis.html",
    "title": "Time Complexity Analysis",
    "section": "",
    "text": "We analyse complexity for mainly: 1. Very large input sizes 2. Worst case scenarios\nIf \\(T(n) = n^3 + 3*n^2 + 4^n + 2\\) then for \\(n \\rightarrow \\infty\\) , \\(T(n) \\approx n^3\\) which means \\(O(n^3)\\)\nBasically, 1. drop the lower order terms. 2. drop the constant multiplier.",
    "crumbs": [
      "basics",
      "Time Complexity Analysis"
    ]
  },
  {
    "objectID": "basics/time-complexity-analysis.html#fundamentals",
    "href": "basics/time-complexity-analysis.html#fundamentals",
    "title": "Time Complexity Analysis",
    "section": "",
    "text": "We analyse complexity for mainly: 1. Very large input sizes 2. Worst case scenarios\nIf \\(T(n) = n^3 + 3*n^2 + 4^n + 2\\) then for \\(n \\rightarrow \\infty\\) , \\(T(n) \\approx n^3\\) which means \\(O(n^3)\\)\nBasically, 1. drop the lower order terms. 2. drop the constant multiplier.",
    "crumbs": [
      "basics",
      "Time Complexity Analysis"
    ]
  },
  {
    "objectID": "basics/time-complexity-analysis.html#rules",
    "href": "basics/time-complexity-analysis.html#rules",
    "title": "Time Complexity Analysis",
    "section": "Rules",
    "text": "Rules\n\nRunning time = \\(\\sum\\) running time of all fragments\nConditional Statements: Pick complexity of condition which is the worst case",
    "crumbs": [
      "basics",
      "Time Complexity Analysis"
    ]
  },
  {
    "objectID": "basics/time-complexity-analysis.html#types",
    "href": "basics/time-complexity-analysis.html#types",
    "title": "Time Complexity Analysis",
    "section": "Types",
    "text": "Types\n\nConstant time – O(1)\nLinear time – O(n)\nLogarithmic time – O(log n)\nQuadratic time – O(n^2)\nCubic time – O(n^3)\nFactorial time - O(n!)",
    "crumbs": [
      "basics",
      "Time Complexity Analysis"
    ]
  },
  {
    "objectID": "basics/overfitting.html",
    "href": "basics/overfitting.html",
    "title": "Overfitting",
    "section": "",
    "text": "What is overfitting?\nOverfitting happens when a machine learning model learns the training data too well, including the noise or random fluctuations in the data, to the extent that it performs poorly on new, unseen data. It’s like studying only the exact questions that might appear on a test without understanding the underlying concepts.\n\n\nWhat causes overfitting?\nOverfitting can occur due to several reasons:\n\nComplexity of the Model: If the model is too complex relative to the amount of training data available, it can capture noise or random fluctuations in the data instead of the underlying patterns.\nLimited Training Data: Insufficient training data can lead to overfitting because the model may learn from noise or outliers rather than generalizing well to new data.\nFeature Engineering: Including irrelevant features or too many features in the model can cause overfitting, especially if those features are noisy or not representative of the underlying relationship.\nInadequate Regularization: Regularization techniques like L1 or L2 regularization are used to prevent overfitting by penalizing overly complex models. If regularization parameters are not tuned properly, it can lead to overfitting.\nData Leakage: Data leakage occurs when information from the test set or information that would not be available in a real-world scenario is inadvertently included in the training data, leading to overly optimistic performance metrics and overfitting.\n\nAvoiding overfitting involves techniques like cross-validation, regularization, feature selection, and increasing the amount of training data.\n\n\nHow can we prevent overfitting?\nTo prevent overfitting in machine learning models, you can employ several techniques:\n\nCross-validation: Split the dataset into multiple subsets for training and testing. Cross-validation helps evaluate the model’s performance on unseen data and can prevent overfitting by ensuring the model generalizes well.\nRegularization: Apply techniques like L1 regularization (Lasso) or L2 regularization (Ridge) to penalize overly complex models. This discourages the model from fitting noise in the training data.\nFeature selection: Choose only the most relevant features that contribute to the model’s performance. Removing irrelevant or redundant features can help prevent overfitting.\nEarly stopping: Monitor the model’s performance on a validation set during training and stop training when performance starts to degrade. This prevents the model from becoming overly specialized to the training data.\nData augmentation: Increase the diversity of the training data by applying transformations like rotation, scaling, or adding noise. This helps the model generalize better to unseen data.\nEnsemble methods: Combine predictions from multiple models to improve generalization and reduce overfitting. Techniques like bagging, boosting, and stacking can be effective in preventing overfitting.\nCross-validation: Split the dataset into multiple subsets for training and testing. Cross-validation helps evaluate the model’s performance on unseen data and can prevent overfitting by ensuring the model generalizes well.\n\nBy applying these techniques, you can reduce the risk of overfitting and build machine learning models that generalize well to new data.",
    "crumbs": [
      "basics",
      "Overfitting"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html",
    "href": "ml-system-design/ml-system-design-overview.html",
    "title": "ML System Design Overview",
    "section": "",
    "text": "Types of questions that are asked in ML system design interviews are:\n\nBuild a system that shows relevant ads for search engines.\nRecommend movies to a user on Netflix.\nExtract all persons, locations, and organizations from a given corpus of documents.\n\nKey points of discsussion in ML system design are:\n\nProblem Setting\nUnderstanding the scale and latency requirements\n\nLatency\nScale\n\nDefining metrics\n\nOffline metrics\nOnline metrics\n\nArchitecture discussion\n\nArchitecting for scale\n\nOffline model building and evaluation\n\nTraining data\nFeature Engineering\nModel building\n\nOnline model execution and evaluation\nIterative model improvements",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#key-steps-in-ml-system-design",
    "href": "ml-system-design/ml-system-design-overview.html#key-steps-in-ml-system-design",
    "title": "ML System Design Overview",
    "section": "",
    "text": "Types of questions that are asked in ML system design interviews are:\n\nBuild a system that shows relevant ads for search engines.\nRecommend movies to a user on Netflix.\nExtract all persons, locations, and organizations from a given corpus of documents.\n\nKey points of discsussion in ML system design are:\n\nProblem Setting\nUnderstanding the scale and latency requirements\n\nLatency\nScale\n\nDefining metrics\n\nOffline metrics\nOnline metrics\n\nArchitecture discussion\n\nArchitecting for scale\n\nOffline model building and evaluation\n\nTraining data\nFeature Engineering\nModel building\n\nOnline model execution and evaluation\nIterative model improvements",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#sec-problem-setting",
    "href": "ml-system-design/ml-system-design-overview.html#sec-problem-setting",
    "title": "ML System Design Overview",
    "section": "Problem Setting",
    "text": "Problem Setting\nUsually the problem statement by the interviewer might be broad and it is important to ask clarifying questions to understand the problem better. Ask clarifying questions till you feel that all aspects of the problem are clear to you and convey your understanding to the interviewer so that both of you are on the same page.\nSome questions that you might ask are:\n\nWhat is the objective of the system?\nDoes it work like XXX ? (where XXX is a similar system that you know of)\nHow can one obtain such inputs?\nHow will the output be consumed?\n\nRemember that post this step, you should have a fair idea of the problem statement and the objective of the system.",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#sec-scale-latency",
    "href": "ml-system-design/ml-system-design-overview.html#sec-scale-latency",
    "title": "ML System Design Overview",
    "section": "Understanding the scale and latency requirements",
    "text": "Understanding the scale and latency requirements\nThis can be useful when identifying where and how caching might need to be implemented.\n\nLatency\nUnderstanding latency requirements will help in indentifying the correct ML solution / model to use.\n\n\nScale\nScale will help us understand how many requests we can expect for the system.",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#sec-defining-metrics",
    "href": "ml-system-design/ml-system-design-overview.html#sec-defining-metrics",
    "title": "ML System Design Overview",
    "section": "Defining metrics",
    "text": "Defining metrics\nsee here\n\nOffline metrics\nThese metrics are used when the model is being built and evaluated. In supervised setting these metrics would be calculated on the validation set, where we will have the ground truth. Some example metrics are:\n\nAccuracy\nPrecision\nRecall\nF1 score\nAUC-ROC\n\n\n\nOnline metrics\nThese metrics are used when the model is being run in the production environment. These are basically used to monitor the performance of the model in real time. Mainly to ensure that the model is performing as expected. Some example metrics are:\n\nClick through rate\nConversion rate\nBound rate",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#sec-architecture",
    "href": "ml-system-design/ml-system-design-overview.html#sec-architecture",
    "title": "ML System Design Overview",
    "section": "Architecture discussion",
    "text": "Architecture discussion\nDiscussion on how the system will be built given the requirements and scale. Here we will talk the various components of the system and what aspects of the requirements or performance will each of the component address.\n\nArchitecting for scale\nTo handle large scale, we might need to have a funneled approach in our ML system. With each layer filtering out irreleavant samples/examples and increasing in complexity. In that way, the most complex model (which will ususally be the most computationally expensive) will only be run on a small subset of the data. Another way to handle scale for a different use case might be to perform batch predictions. This would ensure that out resources are used optimally and we are able to handle multiple requests at the same time. When making batch predictions, we need to consider what is an acceptable linger time for a request, as this will enable us to collect multiple requests and make predictions in a batch.",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#sec-offline-model-building",
    "href": "ml-system-design/ml-system-design-overview.html#sec-offline-model-building",
    "title": "ML System Design Overview",
    "section": "Offline model building and evaluation",
    "text": "Offline model building and evaluation\nThis is the step where we actually build the most optimal model. For model building the first thing required is training data.\n\nTraining data\n\nHuman annotated data : We can have crowd sourced data or data annotated by experts. If the task is generic, we can also utilize pre-existing datasets.\nUser Interaction data : User interaction data could be used in creating personalisation models, where we can use user interactions to understand preferences and recommend items accordingly.\nSynthetic data : Synthetic data can be used when we do not have enough data. This can be generated using techniques like data augmentation. Sometimes we can also use an existing pretriained more complex model to generate this synthetic data, and use that data to train a smaller more robust model.\n\n\n\nFeature Engineering\nFeature engineering is the process of transforming raw data into features that can be used in the model. This is a crucial step as the model’s performance is highly dependent on the features used. Some common feature engineering techniques are:\n\nOne hot encoding\nNormalization\nStandardization\nBinning\nMissing value imputation\n\n\n\nModel building\nBased on offline evaluation metrics, we can train multiple models and compare / contrast their performance. Here the main choice of would be the model architecture. Usually, we would use an random forest or a GBM model for tabular data, and a CNN or Transformer for image and text data. Random forests are good for tabular data because they are robust to outliers and can handle missing data well. GBM models are good for tabular data because they are able to capture non-linear relationships in the data. CNNs are good for image data because they are able to capture spatial relationships in the data. Transformers are good for text data because they are able to capture the sequential relationships in the data.",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#sec-online-model-execution",
    "href": "ml-system-design/ml-system-design-overview.html#sec-online-model-execution",
    "title": "ML System Design Overview",
    "section": "Online model execution and evaluation",
    "text": "Online model execution and evaluation\nAfter the model is trained and deployed, we need to monitor its performance using online metrics. It is also a good idea to store model predictions as it helps create an organic training data. This data can be used to retrain the model and improve its performance. If possible, we can also incorporate feedback from the users to improve the model.",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-system-design-overview.html#sec-iterative-model-improvements",
    "href": "ml-system-design/ml-system-design-overview.html#sec-iterative-model-improvements",
    "title": "ML System Design Overview",
    "section": "Iterative model improvements",
    "text": "Iterative model improvements\nBased on the online metrics, we can make changes to the model to improve its performance. This could be done by retraining the model with new data or by changing the model architecture. We can also use techniques like hyperparameter tuning to improve the model’s performance. It is also important to monitor the model’s drift and retrain the model if necessary.",
    "crumbs": [
      "ml-system-design",
      "ML System Design Overview"
    ]
  },
  {
    "objectID": "ml-system-design/ml-metrics.html",
    "href": "ml-system-design/ml-metrics.html",
    "title": "ML Metrics",
    "section": "",
    "text": "Definition - evaluates the fraction of relevant items that were retrieved by the model over the total relevant items.\nUse cases - used in information retieval, recommendation systems, etc. When we need to ensure that all relavant items are retrieved by the model (in cases where we can’t afford to miss any relevant items).\n\n\n\n\n\nDefinition - evaluates the fraction of relevant items that were retrieved by the model over the total items retrieved.\nUse cases - used in information retieval, recommendation systems, etc. When we need to ensure that the items retrieved by the model are relevant (in cases where we can’t afford to have irrelevant items in the retrieved list).\n\n\n\n\n\nDefinition - MRR measures the effectiveness of a system in ranking the most relevant items at the top of a list. It calculates the average of reciprocal ranks of the first correct item found in each ranked list of results: $ MRR = * _{i=1}^{m} $ where \\(m\\) is the number of queries and \\(rank_i\\) is the position of the first correct item in the ranked list of results for query \\(i\\).\nUse cases - useful when we need to ensure that most relavant item is ranked on the top of the list.",
    "crumbs": [
      "ml-system-design",
      "ML Metrics"
    ]
  },
  {
    "objectID": "ml-system-design/ml-metrics.html#offline-metrics",
    "href": "ml-system-design/ml-metrics.html#offline-metrics",
    "title": "ML Metrics",
    "section": "",
    "text": "Definition - evaluates the fraction of relevant items that were retrieved by the model over the total relevant items.\nUse cases - used in information retieval, recommendation systems, etc. When we need to ensure that all relavant items are retrieved by the model (in cases where we can’t afford to miss any relevant items).\n\n\n\n\n\nDefinition - evaluates the fraction of relevant items that were retrieved by the model over the total items retrieved.\nUse cases - used in information retieval, recommendation systems, etc. When we need to ensure that the items retrieved by the model are relevant (in cases where we can’t afford to have irrelevant items in the retrieved list).\n\n\n\n\n\nDefinition - MRR measures the effectiveness of a system in ranking the most relevant items at the top of a list. It calculates the average of reciprocal ranks of the first correct item found in each ranked list of results: $ MRR = * _{i=1}^{m} $ where \\(m\\) is the number of queries and \\(rank_i\\) is the position of the first correct item in the ranked list of results for query \\(i\\).\nUse cases - useful when we need to ensure that most relavant item is ranked on the top of the list.",
    "crumbs": [
      "ml-system-design",
      "ML Metrics"
    ]
  },
  {
    "objectID": "ml-system-design/ml-metrics.html#normalized-discounted-cumulative-gain-ndcg",
    "href": "ml-system-design/ml-metrics.html#normalized-discounted-cumulative-gain-ndcg",
    "title": "ML Metrics",
    "section": "Normalized Discounted Cumulative Gain (NDCG)",
    "text": "Normalized Discounted Cumulative Gain (NDCG)\n\nDefinition - NDCG is a measure of ranking quality, which evaluates the ranking of the relevant items in the list of retrieved items. It is calculated as the ratio of DCG to IDCG: $ NDCG = $ where DCG is the discounted cumulative gain and IDCG is the ideal discounted cumulative gain. DCG is calculated as: $ DCG = {i=1}^{m} $ where \\(rel_i\\) is the relevance of the item at position \\(i\\) and \\(m\\) is the number of items in the list. IDCG is calculated as: $ IDCG = {i=1}^{m} $ where \\(rel_i\\) is the relevance of the item at position \\(i\\) and \\(m\\) is the number of items in the list.\nUse cases - used in information retrieval, recommendation systems, etc. When we need to evaluate the ranking quality of the model.",
    "crumbs": [
      "ml-system-design",
      "ML Metrics"
    ]
  },
  {
    "objectID": "ml-system-design/ml-metrics.html#online-metrics",
    "href": "ml-system-design/ml-metrics.html#online-metrics",
    "title": "ML Metrics",
    "section": "Online metrics",
    "text": "Online metrics\n\nClick Through Rate (CTR)\n\nDefinition - CTR measures the ratio of clicks to impressions. It is calculated as \\(CTR = \\frac{Clicks}{Impressions}\\). Where Impressions is the number of times the ad was shown / recommended and Clicks is the number of times the ad was clicked.\nUse cases - Most common metric to see the effectiveness of a algorithm or model in a production environment. Ideally for a recommender system, an improved model would increase the CTR on the recommended items.\n\n\n\nConversion Rate\nConversion rate measures the ratio of conversions to clicks. It is calculated as \\(Conversion Rate = \\frac{Conversions}{Clicks}\\). Where Conversions is the number of times the user took the desired action after clicking on the ad.\n\n\nBounce Rate\nKind of opposite to the conversion rate, bounce rate measures the ratio of users who left the site without performing the desired action.",
    "crumbs": [
      "ml-system-design",
      "ML Metrics"
    ]
  },
  {
    "objectID": "fastai/lecture-2.html",
    "href": "fastai/lecture-2.html",
    "title": "Lecture 2",
    "section": "",
    "text": "import os; os.environ[\"PYTORCH_ENABLE_MPS_FALLBACK\"] = \"1\"\n\n\nfrom duckduckgo_search import DDGS\nfrom fastcore.all import *\nfrom fastai.vision.all import *\n\n\nSEED = 42\n\n\ndef search_image(search_str: str, max_items: int=100): return L(DDGS().images(search_str, max_results=max_items)).itemgot(\"image\")\n\n\npath = Path(\"/tmp/\")\n\n\nfrom fastdownload import download_url\nimport time\n\nsearches = 'normal car', 'damaged car'\n\nfor search in searches:\n    dest = path / search\n    download_images(dest, urls=search_image(search))\n    time.sleep(10)\n    download_images(dest, urls=search_image(search + ' on road'))\n    time.sleep(10)\n    download_images(dest, urls=search_image(search + ' parked'))\n\n\nfailed = verify_images(get_image_files(path))\nfailed.map(Path.unlink)\n\n(#0) []",
    "crumbs": [
      "fastai",
      "Lecture 2"
    ]
  },
  {
    "objectID": "fastai/lecture-2.html#data-prep",
    "href": "fastai/lecture-2.html#data-prep",
    "title": "Lecture 2",
    "section": "",
    "text": "import os; os.environ[\"PYTORCH_ENABLE_MPS_FALLBACK\"] = \"1\"\n\n\nfrom duckduckgo_search import DDGS\nfrom fastcore.all import *\nfrom fastai.vision.all import *\n\n\nSEED = 42\n\n\ndef search_image(search_str: str, max_items: int=100): return L(DDGS().images(search_str, max_results=max_items)).itemgot(\"image\")\n\n\npath = Path(\"/tmp/\")\n\n\nfrom fastdownload import download_url\nimport time\n\nsearches = 'normal car', 'damaged car'\n\nfor search in searches:\n    dest = path / search\n    download_images(dest, urls=search_image(search))\n    time.sleep(10)\n    download_images(dest, urls=search_image(search + ' on road'))\n    time.sleep(10)\n    download_images(dest, urls=search_image(search + ' parked'))\n\n\nfailed = verify_images(get_image_files(path))\nfailed.map(Path.unlink)\n\n(#0) []",
    "crumbs": [
      "fastai",
      "Lecture 2"
    ]
  },
  {
    "objectID": "fastai/lecture-2.html#training-the-model",
    "href": "fastai/lecture-2.html#training-the-model",
    "title": "Lecture 2",
    "section": "Training the model",
    "text": "Training the model\n\ndls = DataBlock(\n    blocks=(ImageBlock, CategoryBlock),\n    get_items=get_image_files,\n    splitter=RandomSplitter(valid_pct=0.1, seed=SEED),\n    get_y=parent_label,\n    batch_tfms=aug_transforms(mult=2),\n    item_tfms=[Resize(192, method=\"squish\")]\n).dataloaders(path)\n\n/Users/akhilvempali/miniconda3/envs/ml/lib/python3.9/site-packages/torch/_tensor.py:1386: UserWarning: The operator 'aten::_linalg_solve_ex.result' is not currently supported on the MPS backend and will fall back to run on the CPU. This may have performance implications. (Triggered internally at /Users/runner/miniforge3/conda-bld/pytorch-recipe_1699324334443/work/aten/src/ATen/mps/MPSFallback.mm:13.)\n  ret = func(*args, **kwargs)\n\n\n\ndls.train.show_batch()\n\n\n\n\n\n\n\n\n\nlearn = vision_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(4)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.923583\n0.211899\n0.080645\n00:34\n\n\n\n\n\n/Users/akhilvempali/miniconda3/envs/ml/lib/python3.9/site-packages/PIL/Image.py:970: UserWarning: Palette images with Transparency expressed in bytes should be converted to RGBA images\n  warnings.warn(\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.443422\n0.067423\n0.016129\n00:33\n\n\n1\n0.404157\n0.036878\n0.000000\n00:33\n\n\n2\n0.325895\n0.081799\n0.032258\n00:33\n\n\n3\n0.280252\n0.074519\n0.016129\n00:34",
    "crumbs": [
      "fastai",
      "Lecture 2"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html",
    "href": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html",
    "title": "1255. Maximum Score Words Formed by Letters",
    "section": "",
    "text": "link\nGiven a list of words, list of single letters (might be repeating) and score of every character.\nReturn the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).\nIt is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.\nExample 1:\n\nInput: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\nOutput: 23\nExplanation:\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\nWords \"dad\" and \"dog\" only get a score of 21.\nExample 2:\n\nInput: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\nOutput: 27\nExplanation:\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27.\nWord \"xxxz\" only get a score of 25.\nExample 3:\n\nInput: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\nOutput: 0\nExplanation:\nLetter \"e\" can only be used once.",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "1255. Maximum Score Words Formed by Letters"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html#problem",
    "href": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html#problem",
    "title": "1255. Maximum Score Words Formed by Letters",
    "section": "",
    "text": "link\nGiven a list of words, list of single letters (might be repeating) and score of every character.\nReturn the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).\nIt is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.\nExample 1:\n\nInput: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\nOutput: 23\nExplanation:\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\nWords \"dad\" and \"dog\" only get a score of 21.\nExample 2:\n\nInput: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\nOutput: 27\nExplanation:\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27.\nWord \"xxxz\" only get a score of 25.\nExample 3:\n\nInput: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\nOutput: 0\nExplanation:\nLetter \"e\" can only be used once.",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "1255. Maximum Score Words Formed by Letters"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html#constraints",
    "href": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html#constraints",
    "title": "1255. Maximum Score Words Formed by Letters",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= words.length &lt;= 14\n1 &lt;= words[i].length &lt;= 15\n1 &lt;= letters.length &lt;= 100\nletters[i].length == 1\nscore.length == 26\n0 &lt;= score[i] &lt;= 10\nwords[i], letters[i] contains only lower case English letters.",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "1255. Maximum Score Words Formed by Letters"
    ]
  },
  {
    "objectID": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html#solution",
    "href": "coding-problems/backtracking/lc-1255-maximum-score-words-formed-by-letters.html#solution",
    "title": "1255. Maximum Score Words Formed by Letters",
    "section": "Solution",
    "text": "Solution\n\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -&gt; int:\n\n        max_score = 0\n\n        letters = Counter(letters)\n\n        def get_score(c): return score[ord(c)-ord('a')]\n\n        def rec(x=words, s=0, y=[]):\n            # print(letters, s, y)\n            nonlocal max_score\n            \n            if not x: max_score = max(max_score, s); return\n\n            w = x[0] # select word\n            ws = 0\n            chars_used = []\n            \n            for i, c in enumerate(w): # check if word can be formed and add score\n                if not letters[c]: i-=1; break\n                chars_used.append(c)\n                letters[c] -= 1\n                ws += get_score(c)\n            \n            if i==len(w)-1: rec(x[1:], s+ws, y+[w]) # if word can be formed, recurse\n            \n            for c in chars_used: letters[c]+=1 # backtrack\n            \n            rec(x[1:], s, y) # recurse without selecting word\n        rec()\n        return max_score",
    "crumbs": [
      "coding-problems",
      "backtracking",
      "1255. Maximum Score Words Formed by Letters"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html",
    "href": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html",
    "title": "552. Student Attendance Record II",
    "section": "",
    "text": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n'A': Absent.\n'L': Late.\n'P': Present.\n\nAny student is eligible for an attendance award if they meet both of the following criteria:\nThe student was absent ('A') for strictly fewer than 2 days total. The student was never late ('L') for 3 or more consecutive days. Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 10^9 + 7.\nExample 1:\n\nInput: n = 2\nOutput: 8\nExplanation: There are 8 records with length 2 that are eligible for an award:\n\"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\nOnly \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2).\nExample 2:\n\nInput: n = 1\nOutput: 3\nExample 3:\n\nInput: n = 10101\nOutput: 183236316",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "552. Student Attendance Record II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html#problem",
    "href": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html#problem",
    "title": "552. Student Attendance Record II",
    "section": "",
    "text": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n'A': Absent.\n'L': Late.\n'P': Present.\n\nAny student is eligible for an attendance award if they meet both of the following criteria:\nThe student was absent ('A') for strictly fewer than 2 days total. The student was never late ('L') for 3 or more consecutive days. Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 10^9 + 7.\nExample 1:\n\nInput: n = 2\nOutput: 8\nExplanation: There are 8 records with length 2 that are eligible for an award:\n\"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\nOnly \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2).\nExample 2:\n\nInput: n = 1\nOutput: 3\nExample 3:\n\nInput: n = 10101\nOutput: 183236316",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "552. Student Attendance Record II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html#constraints",
    "title": "552. Student Attendance Record II",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= n &lt;= 10^5",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "552. Student Attendance Record II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html#solution",
    "href": "coding-problems/dynamic-programming/lc-552-student-attendance-record-ii.html#solution",
    "title": "552. Student Attendance Record II",
    "section": "Solution",
    "text": "Solution\ndp[i] the number of all possible attendance (without 'A') records with length i :\n\nend with \"P\": dp[i-1]\nend with \"PL\": dp[i-2]\nend with \"PLL\": dp[i-3]\nend with \"LLL\": is not allowed\n\nSo dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\nThe number of all possible attendance (with 'A') records with length n: ∑ (dp[i]*dp[n-1-i]) i = 0,1,...,n-1\nThe difficult part to think through is adding 'A' with ∑ (dp[i]*dp[n-1-i]) i = 0,1,...,n-1, For each dp[i], there are dp[i] * dp[n-1-i] combinations to get a result with length N. The result looks like dp[i] +'A' +dp[n-1-i]\n\nclass Solution:\n    def checkRecord(self, n: int) -&gt; int:\n        if n==0: return 0\n        if n==1: return 3\n        MOD = 10**9 + 7\n        dp = [1, 1, 2] # number of possiblities till ith day with only 'P' and 'L'\n        i = 2\n        while i&lt;n:\n            x = (dp[-1]+dp[-2]+dp[-3]) % MOD\n            dp.append(x)\n            i += 1\n        result = dp[-1] + dp[-2] + dp[-3]\n        for i in range(n):\n            result += (dp[i+1]*dp[n-i]) % MOD\n            result %= MOD\n        return result",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "552. Student Attendance Record II"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html",
    "href": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html",
    "title": "790. Domino and Tromino Tiling",
    "section": "",
    "text": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 10^9 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nExample 1:\nInput: n = 3\nOutput: 5\nExplanation: The five different ways are show above.\n\nExample 2:\nInput: n = 1\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "790. Domino and Tromino Tiling"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html#problem",
    "href": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html#problem",
    "title": "790. Domino and Tromino Tiling",
    "section": "",
    "text": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 10^9 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\nExample 1:\nInput: n = 3\nOutput: 5\nExplanation: The five different ways are show above.\n\nExample 2:\nInput: n = 1\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "790. Domino and Tromino Tiling"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html#constraints",
    "title": "790. Domino and Tromino Tiling",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= n &lt;= 1000",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "790. Domino and Tromino Tiling"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html#solution",
    "href": "coding-problems/dynamic-programming/lc-790-domino-and-tromino-tiling.html#solution",
    "title": "790. Domino and Tromino Tiling",
    "section": "Solution",
    "text": "Solution\n\n\nclass Solution:\n    def numTilings(self, n: int) -&gt; int:\n\n        MOD = 10**9 + 7\n        if n&lt;=2: return max(n,1)\n        dp = [0]*(n+1)\n        dp[0], dp[1], dp[2] = 1, 1, 2\n\n        for i in range(3,n+1): dp[i] = 2*dp[i-1]+dp[i-3]\n\n        return dp[-1] % MOD",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "790. Domino and Tromino Tiling"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html",
    "href": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html",
    "title": "2370. Longest Ideal Subsequence",
    "section": "",
    "text": "Link\nYou are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\nExample 1:\n\nInput: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.\nExample 2:\n\nInput: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "2370. Longest Ideal Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html#problem",
    "href": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html#problem",
    "title": "2370. Longest Ideal Subsequence",
    "section": "",
    "text": "Link\nYou are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\nExample 1:\n\nInput: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.\nExample 2:\n\nInput: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "2370. Longest Ideal Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html#constraints",
    "title": "2370. Longest Ideal Subsequence",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= s.length &lt;= 10^5\n0 &lt;= k &lt;= 25\ns consists of lowercase English letters.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "2370. Longest Ideal Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html#solution",
    "href": "coding-problems/dynamic-programming/lc-2370-longest-ideal-subsequence.html#solution",
    "title": "2370. Longest Ideal Subsequence",
    "section": "Solution",
    "text": "Solution\n\nclass Solution:\n    def longestIdealString(self, s: str, k: int) -&gt; int:\n        offset = ord('a'), \n        dp = [0]*abs(ord('z')-ord('a')+1) # dp of all subsequence ending with char\n\n        for c in s:\n            i = ord(c)-offset\n            l, h = max(i-k, 0), min(i+k+1, len(dp)) # left and right bound\n            dp[i] = max(dp[l:h])+1 # max of all neighbhouring chars and the sequence they end at\n        \n        return max(dp)",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "2370. Longest Ideal Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html",
    "href": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html",
    "title": "300. Longest Increasing Subsequence",
    "section": "",
    "text": "Link\nGiven an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\n\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\n\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\nExample 3:\n\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "300. Longest Increasing Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html#problem",
    "href": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html#problem",
    "title": "300. Longest Increasing Subsequence",
    "section": "",
    "text": "Link\nGiven an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\n\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\n\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\nExample 3:\n\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "300. Longest Increasing Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html#constraints",
    "title": "300. Longest Increasing Subsequence",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= nums.length &lt;= 2500\n-10^4 &lt;= nums[i] &lt;= 10^4\n\nFollow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "300. Longest Increasing Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html#solution",
    "href": "coding-problems/dynamic-programming/lc-300-longest-increasing-subsequence.html#solution",
    "title": "300. Longest Increasing Subsequence",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -&gt; int:\n\n        n = len(nums)\n        dp = [1]*n # dp[i] means the length of the longest increasing subsequence that ends with nums[i]\n\n        for i in range(n):\n            for j in range(i):\n                if nums[j]&lt;nums[i]: \n                    dp[i] = max(dp[i], dp[j]+1)\n        \n        return max(dp)",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "300. Longest Increasing Subsequence"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html",
    "href": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html",
    "title": "123. Best Time to Buy and Sell Stock III",
    "section": "",
    "text": "Link\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "123. Best Time to Buy and Sell Stock III"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html#problem",
    "href": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html#problem",
    "title": "123. Best Time to Buy and Sell Stock III",
    "section": "",
    "text": "Link\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "123. Best Time to Buy and Sell Stock III"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html#constraints",
    "href": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html#constraints",
    "title": "123. Best Time to Buy and Sell Stock III",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= prices.length &lt;= 10^5\n0 &lt;= prices[i] &lt;= 10^5",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "123. Best Time to Buy and Sell Stock III"
    ]
  },
  {
    "objectID": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html#solution",
    "href": "coding-problems/dynamic-programming/lc-123-best-time-to-buy-and-sell-stock-iii.html#solution",
    "title": "123. Best Time to Buy and Sell Stock III",
    "section": "Solution",
    "text": "Solution\n\nfrom functools import lru_cache\nfrom typing import List\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n\n        @lru_cache\n        def recurse(day: int=0, bought: bool=False, transactions: int=2):\n            \n            if transactions==0 or day&gt;=len(prices): return 0\n\n            result = recurse(day+1, bought, transactions) # skip\n\n            if bought: result = max(result, recurse(day+1, False, transactions-1)+prices[day]) # sell\n            \n            else: result = max(result, recurse(day+1, True, transactions)-prices[day]) # buy\n\n            return result\n        return recurse()",
    "crumbs": [
      "coding-problems",
      "dynamic-programming",
      "123. Best Time to Buy and Sell Stock III"
    ]
  },
  {
    "objectID": "coding-problems/strings/z-alogrithm.html",
    "href": "coding-problems/strings/z-alogrithm.html",
    "title": "Z-Function",
    "section": "",
    "text": "Z array stores the length of the longest substring starting at i which is also a prefix of the string.\n\ns = \"AABBAAABBAAABBA\"\nn = len(s)\nz = [n]\nl = r = 0\nfor i in range(1, n):\n    if i&gt;r: # i is outside the current z-box\n        l = r = i\n        while r&lt;n and s[r]==s[r-l]: r+=1\n        r-=1\n        z.append(r-l+1)\n    else:\n        k = i-l\n        if z[k]&lt;r-i+1: # z[k] is less than the remaining length\n            z.append(z[k])\n        if z[k]&gt;=r-i+1: # z[k] is greater than the remaining length\n            l = r = i\n            while r&lt;n and s[r-l]==s[r]: r+=1\n            r-=1\n            z.append(r-l+1)\n    print(f\"{l=} {r=} {z=}\")\n\nl=1 r=1 z=[15, 1]\nl=2 r=1 z=[15, 1, 0]\nl=3 r=2 z=[15, 1, 0, 0]\nl=4 r=5 z=[15, 1, 0, 0, 2]\nl=5 r=14 z=[15, 1, 0, 0, 2, 10]\nl=5 r=14 z=[15, 1, 0, 0, 2, 10, 1]\nl=5 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0]\nl=5 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0, 0]\nl=5 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0, 0, 2]\nl=10 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0, 0, 2, 5]\nl=10 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0, 0, 2, 5, 1]\nl=10 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0, 0, 2, 5, 1, 0]\nl=10 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0, 0, 2, 5, 1, 0, 0]\nl=14 r=14 z=[15, 1, 0, 0, 2, 10, 1, 0, 0, 2, 5, 1, 0, 0, 1]",
    "crumbs": [
      "coding-problems",
      "strings",
      "Z-Function"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html",
    "href": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html",
    "title": "236. Lowest Common Ancestor of a Binary Tree",
    "section": "",
    "text": "Link\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n\nExample 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\nInput: root = [1,2], p = 1, q = 2\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "trees",
      "236. Lowest Common Ancestor of a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html#problem",
    "href": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html#problem",
    "title": "236. Lowest Common Ancestor of a Binary Tree",
    "section": "",
    "text": "Link\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n\nExample 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\nInput: root = [1,2], p = 1, q = 2\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "trees",
      "236. Lowest Common Ancestor of a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html#constraints",
    "href": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html#constraints",
    "title": "236. Lowest Common Ancestor of a Binary Tree",
    "section": "Constraints",
    "text": "Constraints\n\nThe number of nodes in the tree is in the range [2, 10^5].\n-10^9 &lt;= Node.val &lt;= 10^9\nAll Node.val are unique.\np != q\np and q will exist in the tree.",
    "crumbs": [
      "coding-problems",
      "trees",
      "236. Lowest Common Ancestor of a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html#solution",
    "href": "coding-problems/trees/lc-236-lowest-common-ancestor-of-a-binary-tree.html#solution",
    "title": "236. Lowest Common Ancestor of a Binary Tree",
    "section": "Solution",
    "text": "Solution\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':\n\n        if root in {p, q}: return root\n\n        left = right = None\n\n        if root.left: left = self.lowestCommonAncestor(root.left, p, q)\n        if root.right: right = self.lowestCommonAncestor(root.right, p, q)\n        \n        if left and right: return root\n        else: return left or right",
    "crumbs": [
      "coding-problems",
      "trees",
      "236. Lowest Common Ancestor of a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html",
    "href": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html",
    "title": "1372. Longest ZigZag Path in a Binary Tree",
    "section": "",
    "text": "Link\nYou are given the root of a binary tree.\nA ZigZag path for a binary tree is defined as follow:\n\nChoose any node in the binary tree and a direction (right or left).\nIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\nChange the direction from right to left or from left to right.\nRepeat the second and third steps until you can’t move in the tree.\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\nReturn the longest ZigZag path contained in that tree.\n\nExample 1:\nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right).\n\nExample 2:\nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right).\n\nExample 3:\nInput: root = [1]\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "trees",
      "1372. Longest ZigZag Path in a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html#problem",
    "href": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html#problem",
    "title": "1372. Longest ZigZag Path in a Binary Tree",
    "section": "",
    "text": "Link\nYou are given the root of a binary tree.\nA ZigZag path for a binary tree is defined as follow:\n\nChoose any node in the binary tree and a direction (right or left).\nIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\nChange the direction from right to left or from left to right.\nRepeat the second and third steps until you can’t move in the tree.\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\nReturn the longest ZigZag path contained in that tree.\n\nExample 1:\nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right).\n\nExample 2:\nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right).\n\nExample 3:\nInput: root = [1]\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "trees",
      "1372. Longest ZigZag Path in a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html#constraints",
    "href": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html#constraints",
    "title": "1372. Longest ZigZag Path in a Binary Tree",
    "section": "Constraints:",
    "text": "Constraints:\n\nThe number of nodes in the tree is in the range [1, 5 * 10^4].\n1 &lt;= Node.val &lt;= 100",
    "crumbs": [
      "coding-problems",
      "trees",
      "1372. Longest ZigZag Path in a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html#solution",
    "href": "coding-problems/trees/lc-1372-longest-zigzag-path-in-a-binary-tree.html#solution",
    "title": "1372. Longest ZigZag Path in a Binary Tree",
    "section": "Solution",
    "text": "Solution\nRecursive return [left, right, result], where:\n\nleft is the maximum length in direction of root.left\nright is the maximum length in direction of root.right\nresult is the maximum length in the whole sub tree.\n\n\n# Definition for a binary tree node.\nfrom typing import Optional\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def longestZigZag(self, root: Optional[TreeNode]) -&gt; int:\n        def dfs(node):\n            if not node: return [-1, -1, -1] \n            left, right = dfs(node.left), dfs(node.right)\n            mx_lft = left[1]+1\n            mx_right = right[0]+1\n            mx = max(mx_lft, mx_right, left[2], right[2])\n            return [mx_lft, mx_right, mx]\n        return dfs(root)[-1]",
    "crumbs": [
      "coding-problems",
      "trees",
      "1372. Longest ZigZag Path in a Binary Tree"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html",
    "href": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html",
    "title": "230. Kth Smallest Element in a BST",
    "section": "",
    "text": "link\nGiven the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3",
    "crumbs": [
      "coding-problems",
      "trees",
      "230. Kth Smallest Element in a BST"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html#problem",
    "href": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html#problem",
    "title": "230. Kth Smallest Element in a BST",
    "section": "",
    "text": "link\nGiven the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3",
    "crumbs": [
      "coding-problems",
      "trees",
      "230. Kth Smallest Element in a BST"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html#constraints",
    "href": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html#constraints",
    "title": "230. Kth Smallest Element in a BST",
    "section": "Constraints",
    "text": "Constraints\n\nThe number of nodes in the tree is n.\n1 &lt;= k &lt;= n &lt;= 10^4\n0 &lt;= Node.val &lt;= 10^4\n\nFollow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
    "crumbs": [
      "coding-problems",
      "trees",
      "230. Kth Smallest Element in a BST"
    ]
  },
  {
    "objectID": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html#solution",
    "href": "coding-problems/trees/lc-230-kth-smallest-element-in-a-bst.html#solution",
    "title": "230. Kth Smallest Element in a BST",
    "section": "Solution",
    "text": "Solution\n\n# Definition for a binary tree node.\nfrom typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:\n\n        def rec(node):\n            nonlocal k\n            if node is None:\n                return None\n            left = rec(node.left)\n            if isinstance(left, int):\n                return left\n            k -= 1\n            if k == 0:\n                return node.val\n            return rec(node.right)\n\n        return rec(root)",
    "crumbs": [
      "coding-problems",
      "trees",
      "230. Kth Smallest Element in a BST"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-212-word-search-ii.html",
    "href": "coding-problems/graphs/lc-212-word-search-ii.html",
    "title": "212. Word Search II",
    "section": "",
    "text": "link\nGiven an m x nboard of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n\n\nexample 1\n\n\nInput: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n\n\n\nexample 2\n\n\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []",
    "crumbs": [
      "coding-problems",
      "graphs",
      "212. Word Search II"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-212-word-search-ii.html#problem",
    "href": "coding-problems/graphs/lc-212-word-search-ii.html#problem",
    "title": "212. Word Search II",
    "section": "",
    "text": "link\nGiven an m x nboard of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n\n\nexample 1\n\n\nInput: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n\n\n\nexample 2\n\n\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []",
    "crumbs": [
      "coding-problems",
      "graphs",
      "212. Word Search II"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-212-word-search-ii.html#constraints",
    "href": "coding-problems/graphs/lc-212-word-search-ii.html#constraints",
    "title": "212. Word Search II",
    "section": "Constraints",
    "text": "Constraints\n\nm == board.length\nn == board[i].length\n1 &lt;= m, n &lt;= 12\nboard[i][j] is a lowercase English letter.\n1 &lt;= words.length &lt;= 3 * 10^4\n1 &lt;= words[i].length &lt;= 10\nwords[i] consists of lowercase English letters. = All the strings of words are unique.\n\n\nfrom collections import defaultdict\nfrom typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:\n\n        class TrieNode:\n            def __init__(self):\n                self.is_word = False\n                self.children = defaultdict(TrieNode)\n            \n            def insert(self, word):\n                n = self\n                for c in word: n = n.children[c]\n                n.is_word = True\n                return True\n            \n            @lru_cache\n            def search(self, word):\n                n = self\n                for c in word:\n                    if c not in n.children.keys(): return (False, False)\n                    n = n.children[c]\n                return (True, n.is_word)\n            \n            def remove(self, word):\n                n = self\n                for c in word:\n                    if c not in n.children.keys(): return False\n                    n = n.children[c]\n                n._is_word = False\n                return True\n\n        result, root = [], TrieNode()\n        [root.insert(w) for w in words] # insert all words into trie\n        \n        def dfs(i, j, node, ws=\"\"):\n            if node.is_word: # if word is found, add to result and remove it from trie\n                result.append(ws); node.is_word = False\n            if not(0&lt;=i&lt;len(board)) or not(0&lt;=j&lt;len(board[0])): return\n\n            c = board[i][j]\n            node = node.children.get(c, False) # get next node if present else return\n            if not node: return\n            board[i][j] = \"#\" # mark visited\n            for ih, jh in [(i+1,j), (i-1,j), (i, j+1), (i,j-1)]:\n                dfs(ih, jh, node, ws+c)\n            board[i][j] = c # backtrack\n            return\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, root)\n        \n        return list(set(result))",
    "crumbs": [
      "coding-problems",
      "graphs",
      "212. Word Search II"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-211-design-add-and-search-words-data-structure.html",
    "href": "coding-problems/graphs/lc-211-design-add-and-search-words-data-structure.html",
    "title": "211. Design Add and Search Words Data Structure",
    "section": "",
    "text": "Link\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\nImplement the WordDictionary class:\n\nWordDictionary() Initializes the object.\nvoid addWord(word) Adds word to the data structure, it can be matched later.\nbool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\n\nExample:\nInput\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True",
    "crumbs": [
      "coding-problems",
      "graphs",
      "211. Design Add and Search Words Data Structure"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-211-design-add-and-search-words-data-structure.html#problem",
    "href": "coding-problems/graphs/lc-211-design-add-and-search-words-data-structure.html#problem",
    "title": "211. Design Add and Search Words Data Structure",
    "section": "",
    "text": "Link\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\nImplement the WordDictionary class:\n\nWordDictionary() Initializes the object.\nvoid addWord(word) Adds word to the data structure, it can be matched later.\nbool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\n\nExample:\nInput\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True",
    "crumbs": [
      "coding-problems",
      "graphs",
      "211. Design Add and Search Words Data Structure"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-211-design-add-and-search-words-data-structure.html#constraints",
    "href": "coding-problems/graphs/lc-211-design-add-and-search-words-data-structure.html#constraints",
    "title": "211. Design Add and Search Words Data Structure",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= word.length &lt;= 25\nword in addWord consists of lowercase English letters.\nword in search consist of '.' or lowercase English letters.\nThere will be at most 2 dots in word for search queries.\nAt most 10^4 calls will be made to addWord and search.\n\n\nfrom collections import defaultdict, deque\n\nclass TrieNode:\n\n    def __init__(self):\n        self.is_word = False\n        self.children = defaultdict(TrieNode)\n\nclass WordDictionary:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        n = self.root\n        for c in word: n = n.children[c]\n        n.is_word = True\n    \n    def dfs(self, n, w):\n        if not w: return n.is_word\n        if w.startswith(\".\"): return any([self.dfs(_n, w[1:]) for _n in n.children.values()])\n        return self.dfs(n.children[w[0]], w[1:])\n\n    def search(self, word):\n        return self.dfs(self.root, word)\n\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)",
    "crumbs": [
      "coding-problems",
      "graphs",
      "211. Design Add and Search Words Data Structure"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html",
    "href": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html",
    "title": "208. Implement Trie (Prefix Tree)",
    "section": "",
    "text": "link\nA trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nExample 1:\n\nInput\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True",
    "crumbs": [
      "coding-problems",
      "graphs",
      "208. Implement Trie (Prefix Tree)"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html#problem",
    "href": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html#problem",
    "title": "208. Implement Trie (Prefix Tree)",
    "section": "",
    "text": "link\nA trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nExample 1:\n\nInput\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True",
    "crumbs": [
      "coding-problems",
      "graphs",
      "208. Implement Trie (Prefix Tree)"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html#constraints",
    "href": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html#constraints",
    "title": "208. Implement Trie (Prefix Tree)",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= word.length, prefix.length &lt;= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 10^4 calls in total will be made to insert, search, and startsWith.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "208. Implement Trie (Prefix Tree)"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html#solution",
    "href": "coding-problems/graphs/lc-208-implement-trie-prefix-tree.html#solution",
    "title": "208. Implement Trie (Prefix Tree)",
    "section": "Solution",
    "text": "Solution\n\nclass TrieNode:\n    def __init__(self):\n        self.word = False # is this node the end of a word?\n        self.children = {} # children nodes\n\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode() # root node is empty\n\n    def insert(self, word: str) -&gt; None:\n        n = self.root\n        for c in word:\n            if c not in n.children:\n                n.children[c] = TrieNode() \n            n = n.children[c]\n        n.word = True\n\n    def search(self, word: str) -&gt; bool:\n        n = self.root\n        for c in word:\n            if c not in n.children: return False\n            n = n.children[c]\n        return n.word # return True if n is the end of a word\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        n = self.root\n        for c in prefix:\n            if c not in n.children: return False\n            n = n.children[c]\n        return True",
    "crumbs": [
      "coding-problems",
      "graphs",
      "208. Implement Trie (Prefix Tree)"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-427-construct-quad-tree.html",
    "href": "coding-problems/graphs/lc-427-construct-quad-tree.html",
    "title": "427. Construct Quad Tree",
    "section": "",
    "text": "Link\nGiven a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1’s or all 0’s) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don’t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\nExample 1:\n\nInput: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n\n\nExample 2:\n\nInput: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:",
    "crumbs": [
      "coding-problems",
      "graphs",
      "427. Construct Quad Tree"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-427-construct-quad-tree.html#problem",
    "href": "coding-problems/graphs/lc-427-construct-quad-tree.html#problem",
    "title": "427. Construct Quad Tree",
    "section": "",
    "text": "Link\nGiven a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1’s or all 0’s) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don’t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\nExample 1:\n\nInput: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n\n\nExample 2:\n\nInput: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:",
    "crumbs": [
      "coding-problems",
      "graphs",
      "427. Construct Quad Tree"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-427-construct-quad-tree.html#constraints",
    "href": "coding-problems/graphs/lc-427-construct-quad-tree.html#constraints",
    "title": "427. Construct Quad Tree",
    "section": "Constraints",
    "text": "Constraints\n\nn == grid.length == grid[i].length\nn == 2^x where 0 &lt;= x &lt;= 6\n\n\nfrom typing import List\n\n# Definition for a QuadTree node.\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\n\nclass Solution:\n    def isLeaf(self, grid):\n        return all(grid[i][j]==grid[0][0] for i in range(len(grid)) for j in range(len(grid[i])))\n\n    def construct(self, grid: List[List[int]]) -&gt; 'Node':\n\n        if not grid: return None\n\n        if self.isLeaf(grid): return Node(grid[0][0]==1, True, None, None, None, None)\n\n        n = len(grid)\n\n        return Node(\"*\",\n                    False,\n                    self.construct([row[:n//2] for row in grid[:n//2]]),\n                    self.construct([row[n//2:] for row in grid[:n//2]]),\n                    self.construct([row[:n//2] for row in grid[n//2:]]),\n                    self.construct([row[n//2:] for row in grid[n//2:]]),\n                    )",
    "crumbs": [
      "coding-problems",
      "graphs",
      "427. Construct Quad Tree"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-133-clone-graph.html",
    "href": "coding-problems/graphs/lc-133-clone-graph.html",
    "title": "133. Clone Graph",
    "section": "",
    "text": "Link\nGiven a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\nTest case format:\nFor simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\n\n\nExample 1\n\n\nExample 1:\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\nExample 2:\n\n\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\nExample 3:\n\nInput: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "133. Clone Graph"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-133-clone-graph.html#problem",
    "href": "coding-problems/graphs/lc-133-clone-graph.html#problem",
    "title": "133. Clone Graph",
    "section": "",
    "text": "Link\nGiven a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\nTest case format:\nFor simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\n\n\nExample 1\n\n\nExample 1:\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\nExample 2:\n\n\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\nExample 3:\n\nInput: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "133. Clone Graph"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-133-clone-graph.html#constraints",
    "href": "coding-problems/graphs/lc-133-clone-graph.html#constraints",
    "title": "133. Clone Graph",
    "section": "Constraints",
    "text": "Constraints\n\nThe number of nodes in the graph is in the range [0, 100].\n1 &lt;= Node.val &lt;= 100\nNode.val is unique for each node.\nThere are no repeated edges and no self-loops in the graph.\nThe Graph is connected and all nodes can be visited starting from the given node.",
    "crumbs": [
      "coding-problems",
      "graphs",
      "133. Clone Graph"
    ]
  },
  {
    "objectID": "coding-problems/graphs/lc-133-clone-graph.html#solution",
    "href": "coding-problems/graphs/lc-133-clone-graph.html#solution",
    "title": "133. Clone Graph",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import Optional\nfrom collections import deque\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -&gt; Optional['Node']:\n\n        if node is None: return None\n\n        clone_map = {}\n        q = deque([node]) # bfs on the graph and create a clone map of &lt;original node: clone node&gt;\n\n        while q:\n            n = q.popleft()\n            if n in clone_map: continue\n            clone_map[n] = Node(val=n.val)\n            for nn in n.neighbors:\n                q.append(nn)\n        \n        ns = list(clone_map.keys()) # for each original node, find its clone in clone map and add it's neighbhours\n\n        for n in ns:\n            c = clone_map[n]\n            for nn in n.neighbors:\n                c.neighbors.append(clone_map[nn])\n        \n        return clone_map[node]",
    "crumbs": [
      "coding-problems",
      "graphs",
      "133. Clone Graph"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html",
    "href": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html",
    "title": "1442. Count Triplets That Can Form Two Arrays of Equal XOR",
    "section": "",
    "text": "link\nGiven an array of integers arr. We want to select three indices i, j and k where (0 &lt;= i &lt; j &lt;= k &lt; arr.length). Let’s define a and b as follows: - a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] - b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\nNote that ^ denotes the bitwise-xor operation. Return the number of triplets (i, j and k) where a == b.\nExample 1:\n\nInput: arr = [2,3,1,6,7]\nOutput: 4\nExplanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\nExample 2:\n\nInput: arr = [1,1,1,1,1]\nOutput: 10",
    "crumbs": [
      "coding-problems",
      "math",
      "1442. Count Triplets That Can Form Two Arrays of Equal XOR"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html#problem",
    "href": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html#problem",
    "title": "1442. Count Triplets That Can Form Two Arrays of Equal XOR",
    "section": "",
    "text": "link\nGiven an array of integers arr. We want to select three indices i, j and k where (0 &lt;= i &lt; j &lt;= k &lt; arr.length). Let’s define a and b as follows: - a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] - b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\nNote that ^ denotes the bitwise-xor operation. Return the number of triplets (i, j and k) where a == b.\nExample 1:\n\nInput: arr = [2,3,1,6,7]\nOutput: 4\nExplanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\nExample 2:\n\nInput: arr = [1,1,1,1,1]\nOutput: 10",
    "crumbs": [
      "coding-problems",
      "math",
      "1442. Count Triplets That Can Form Two Arrays of Equal XOR"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html#constraints",
    "href": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html#constraints",
    "title": "1442. Count Triplets That Can Form Two Arrays of Equal XOR",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= arr.length &lt;= 300\n1 &lt;= arr[i] &lt;= 10^8",
    "crumbs": [
      "coding-problems",
      "math",
      "1442. Count Triplets That Can Form Two Arrays of Equal XOR"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html#solution",
    "href": "coding-problems/math/lc-1442-count-triplets-that-can-form-two-arrays-of-equal-xor.html#solution",
    "title": "1442. Count Triplets That Can Form Two Arrays of Equal XOR",
    "section": "Solution",
    "text": "Solution\na = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\nAssume a == b, a ^ b = 0 therefore arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] ^ arr[j] ^ arr[j + 1] ^ ... ^ arr[k] = 0\nprefix xor of arr from i to k is 0 therefore prefix_xor[k] = prefix_xor[i - 1]\nWe only need to find out how many pair (i, k) of prefix value are equal. So we can calculate the prefix array first, then brute force count the pair. Because we once we determine the pair (i,k), j can be any value between i and k.\n\nfrom typing import List\n\nclass Solution:\n    def countTriplets(self, arr: List[int]) -&gt; int:\n        n = len(arr)\n        prefix_xor = [0]\n        for x in arr:\n            prefix_xor.append(prefix_xor[-1]^x)\n        r = 0\n        for i in range(n+1):\n            for j in range(i+1, n+1):\n                if prefix_xor[j]==prefix_xor[i]: r += j-i-1\n        return r",
    "crumbs": [
      "coding-problems",
      "math",
      "1442. Count Triplets That Can Form Two Arrays of Equal XOR"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-172-factorial-trailing-zeros.html",
    "href": "coding-problems/math/lc-172-factorial-trailing-zeros.html",
    "title": "172. Factorial Trailing Zeroes",
    "section": "",
    "text": "link\nGiven an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1.\nExample 1:\n\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\nExample 2:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\nExample 3:\n\nInput: n = 0\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "math",
      "172. Factorial Trailing Zeroes"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-172-factorial-trailing-zeros.html#problem",
    "href": "coding-problems/math/lc-172-factorial-trailing-zeros.html#problem",
    "title": "172. Factorial Trailing Zeroes",
    "section": "",
    "text": "link\nGiven an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1.\nExample 1:\n\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\nExample 2:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\nExample 3:\n\nInput: n = 0\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "math",
      "172. Factorial Trailing Zeroes"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-172-factorial-trailing-zeros.html#constraints",
    "href": "coding-problems/math/lc-172-factorial-trailing-zeros.html#constraints",
    "title": "172. Factorial Trailing Zeroes",
    "section": "Constraints",
    "text": "Constraints\n0 &lt;= n &lt;= 104\nFollow up: Could you write a solution that works in logarithmic time complexity?",
    "crumbs": [
      "coding-problems",
      "math",
      "172. Factorial Trailing Zeroes"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-172-factorial-trailing-zeros.html#solution",
    "href": "coding-problems/math/lc-172-factorial-trailing-zeros.html#solution",
    "title": "172. Factorial Trailing Zeroes",
    "section": "Solution",
    "text": "Solution\n\nclass Solution:\n    def trailingZeroes(self, n: int) -&gt; int:\n        fives = 0\n        k = 1\n        while 5**k&lt;n+1:\n            fives += n//5**k\n            k += 1\n        return fives",
    "crumbs": [
      "coding-problems",
      "math",
      "172. Factorial Trailing Zeroes"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html",
    "href": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html",
    "title": "201. Bitwise AND of Numbers Range",
    "section": "",
    "text": "Link\nGiven two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "math",
      "201. Bitwise AND of Numbers Range"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html#problem",
    "href": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html#problem",
    "title": "201. Bitwise AND of Numbers Range",
    "section": "",
    "text": "Link\nGiven two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0",
    "crumbs": [
      "coding-problems",
      "math",
      "201. Bitwise AND of Numbers Range"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html#constraints",
    "href": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html#constraints",
    "title": "201. Bitwise AND of Numbers Range",
    "section": "Constraints",
    "text": "Constraints\n\n0 &lt;= left &lt;= right &lt;= 2^31 - 1",
    "crumbs": [
      "coding-problems",
      "math",
      "201. Bitwise AND of Numbers Range"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html#solution",
    "href": "coding-problems/math/lc-201-bitwise-and-of-numbers-range.html#solution",
    "title": "201. Bitwise AND of Numbers Range",
    "section": "Solution",
    "text": "Solution\nWe need to keep right shifting both numbers until they are equal. The number of times we right shift is the number of bits that are not common in both numbers. We left shift the result by the number of times we right shifted the numbers.\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -&gt; int:\n\n        c = 0\n\n        while left!=right:\n            left &gt;&gt;= 1; right &gt;&gt;= 1\n            c += 1\n        \n        return left &lt;&lt; c",
    "crumbs": [
      "coding-problems",
      "math",
      "201. Bitwise AND of Numbers Range"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-149-max-points-on-a-line.html",
    "href": "coding-problems/math/lc-149-max-points-on-a-line.html",
    "title": "149. Max Points on a Line",
    "section": "",
    "text": "Link\nGiven an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n\n\n\nexample 1\n\n\nExample 1:\n\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\n\n\n\nexample 2\n\n\nExample 2:\n\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4",
    "crumbs": [
      "coding-problems",
      "math",
      "149. Max Points on a Line"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-149-max-points-on-a-line.html#problem",
    "href": "coding-problems/math/lc-149-max-points-on-a-line.html#problem",
    "title": "149. Max Points on a Line",
    "section": "",
    "text": "Link\nGiven an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n\n\n\nexample 1\n\n\nExample 1:\n\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\n\n\n\nexample 2\n\n\nExample 2:\n\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4",
    "crumbs": [
      "coding-problems",
      "math",
      "149. Max Points on a Line"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-149-max-points-on-a-line.html#constraints",
    "href": "coding-problems/math/lc-149-max-points-on-a-line.html#constraints",
    "title": "149. Max Points on a Line",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= points.length &lt;= 300\npoints[i].length == 2\n-10^4 &lt;= xi, yi &lt;= 10^4\nAll the points are unique.\n\n\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -&gt; int:\n\n        n = len(points)\n\n        if n&lt;=2: return n\n\n        def slope(p1, p2):\n            x1, y1 = p1\n            x2, y2 = p2\n            if x1-x2==0: return float('inf')\n            return (y1-y2)/(x1-x2)\n        \n        r = 1\n        \n        for i in range(n):\n            slopes = defaultdict(int) # for each point, count all diff types of slopes with other points, only look ahead\n            for j in range(i+1, n):\n                p1, p2 = points[i], points[j]\n                _slope = slope(p1, p2)\n                slopes[_slope] += 1\n                r = max(r, slopes[_slope])\n        \n        return r+1",
    "crumbs": [
      "coding-problems",
      "math",
      "149. Max Points on a Line"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-861-score-after-flipping-matrix.html",
    "href": "coding-problems/math/lc-861-score-after-flipping-matrix.html",
    "title": "861. Score After Flipping Matrix",
    "section": "",
    "text": "link\nYou are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0’s to 1’s, and all 1’s to 0’s).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).\n\nExample 1:\nInput: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\nExample 2:\n\nInput: grid = [[0]]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "math",
      "861. Score After Flipping Matrix"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-861-score-after-flipping-matrix.html#problem",
    "href": "coding-problems/math/lc-861-score-after-flipping-matrix.html#problem",
    "title": "861. Score After Flipping Matrix",
    "section": "",
    "text": "link\nYou are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0’s to 1’s, and all 1’s to 0’s).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).\n\nExample 1:\nInput: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\nExample 2:\n\nInput: grid = [[0]]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "math",
      "861. Score After Flipping Matrix"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-861-score-after-flipping-matrix.html#constraints",
    "href": "coding-problems/math/lc-861-score-after-flipping-matrix.html#constraints",
    "title": "861. Score After Flipping Matrix",
    "section": "Constraints",
    "text": "Constraints\n\nm == grid.length\nn == grid[i].length\n1 &lt;= m, n &lt;= 20\ngrid[i][j] is either 0 or 1",
    "crumbs": [
      "coding-problems",
      "math",
      "861. Score After Flipping Matrix"
    ]
  },
  {
    "objectID": "coding-problems/math/lc-861-score-after-flipping-matrix.html#solution",
    "href": "coding-problems/math/lc-861-score-after-flipping-matrix.html#solution",
    "title": "861. Score After Flipping Matrix",
    "section": "Solution",
    "text": "Solution\nAssume A is M * N.\n\nA[i][0] is worth 1 &lt;&lt; (N - 1) points, more than the sum of (A[i][1] + .. + A[i][N-1]). We need to toggle all A[i][0] to 1, here I toggle all lines for A[i][0] = 0.\nA[i][j] is worth 1 &lt;&lt; (N - 1 - j) For every col, I count the current number of 1s. After step 1, A[i][j] becomes 1 if A[i][j] == A[i][0]. if M - cur &gt; cur, we can toggle this column to get more 1s. max(cur, M - cur) will be the maximum number of 1s that we can get.\n\n\nfrom typing import List\n\nclass Solution:\n    def matrixScore(self, grid: List[List[int]]) -&gt; int:\n\n        R, C = len(grid), len(grid[0])\n        score = (1 &lt;&lt; C-1)*R\n        \n        for c in range(1, C):\n            curr = sum(grid[r][c]==grid[r][0] for r in range(R))\n            score += max(curr, R-curr) * (1 &lt;&lt; (C-c-1))\n\n        return score",
    "crumbs": [
      "coding-problems",
      "math",
      "861. Score After Flipping Matrix"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html",
    "href": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html",
    "title": "215. Kth Largest Element in an Array",
    "section": "",
    "text": "link\nGiven an integer array nums and an integer k, return the \\(k^{th}\\) largest element in the array.\nNote that it is the \\(k^{th}\\) largest element in the sorted order, not the \\(k^{th}\\) distinct element.\nCan you solve it without sorting?\nExample 1:\n\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\nExample 2:\n\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4",
    "crumbs": [
      "coding-problems",
      "heaps",
      "215. Kth Largest Element in an Array"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html#problem",
    "href": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html#problem",
    "title": "215. Kth Largest Element in an Array",
    "section": "",
    "text": "link\nGiven an integer array nums and an integer k, return the \\(k^{th}\\) largest element in the array.\nNote that it is the \\(k^{th}\\) largest element in the sorted order, not the \\(k^{th}\\) distinct element.\nCan you solve it without sorting?\nExample 1:\n\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\nExample 2:\n\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4",
    "crumbs": [
      "coding-problems",
      "heaps",
      "215. Kth Largest Element in an Array"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html#constraints",
    "href": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html#constraints",
    "title": "215. Kth Largest Element in an Array",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= k &lt;= nums.length &lt;= 105\n-104 &lt;= nums[i] &lt;= 104",
    "crumbs": [
      "coding-problems",
      "heaps",
      "215. Kth Largest Element in an Array"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html#solution",
    "href": "coding-problems/heaps/lc-215-kth-largest-element-in-array.html#solution",
    "title": "215. Kth Largest Element in an Array",
    "section": "Solution",
    "text": "Solution\n\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -&gt; int:\n        \n        nums = [-n for n in nums]\n        heapq.heapify(nums)\n\n        while k!=1:\n            heapq.heappop(nums)\n            k-=1\n        return -heapq.heappop(nums)",
    "crumbs": [
      "coding-problems",
      "heaps",
      "215. Kth Largest Element in an Array"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-295-find-median-from-data-stream.html",
    "href": "coding-problems/heaps/lc-295-find-median-from-data-stream.html",
    "title": "295. Find Median from Data Stream",
    "section": "",
    "text": "link\nThe median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nFor example, for arr = [2,3,4], the median is 3.\nFor example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\n\nImplement the MedianFinder class:\n\nMedianFinder() initializes the MedianFinder object.\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\ndouble findMedian() returns the median of all elements so far. Answers within \\(10^{-5}\\) of the actual answer will be accepted.\n\nExample 1:\n\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0",
    "crumbs": [
      "coding-problems",
      "heaps",
      "295. Find Median from Data Stream"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#problem",
    "href": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#problem",
    "title": "295. Find Median from Data Stream",
    "section": "",
    "text": "link\nThe median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nFor example, for arr = [2,3,4], the median is 3.\nFor example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\n\nImplement the MedianFinder class:\n\nMedianFinder() initializes the MedianFinder object.\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\ndouble findMedian() returns the median of all elements so far. Answers within \\(10^{-5}\\) of the actual answer will be accepted.\n\nExample 1:\n\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0",
    "crumbs": [
      "coding-problems",
      "heaps",
      "295. Find Median from Data Stream"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#constraints",
    "href": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#constraints",
    "title": "295. Find Median from Data Stream",
    "section": "Constraints",
    "text": "Constraints\n\n-105 &lt;= num &lt;= 105\nThere will be at least one element in the data structure before calling findMedian.\nAt most 5 * 104 calls will be made to addNum and findMedian.",
    "crumbs": [
      "coding-problems",
      "heaps",
      "295. Find Median from Data Stream"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#follow-up",
    "href": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#follow-up",
    "title": "295. Find Median from Data Stream",
    "section": "Follow up",
    "text": "Follow up\n\nIf all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\nIf 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?",
    "crumbs": [
      "coding-problems",
      "heaps",
      "295. Find Median from Data Stream"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#solution",
    "href": "coding-problems/heaps/lc-295-find-median-from-data-stream.html#solution",
    "title": "295. Find Median from Data Stream",
    "section": "Solution",
    "text": "Solution\n\nimport heapq\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.lheap = [] # max heap\n        self.rheap = [] # min heap\n\n    def addNum(self, num: int) -&gt; None:\n        lv = -self.lheap[0] if self.lheap else float('-inf')\n        rv = self.rheap[0] if self.rheap else float('inf')\n        if lv&lt;num&lt;rv or num&lt;=lv:\n            heapq.heappush(self.lheap, -num)\n        else:\n            heapq.heappush(self.rheap, num)\n        while len(self.lheap)-len(self.rheap)&gt;1:\n            v = -heapq.heappop(self.lheap)\n            heapq.heappush(self.rheap, v)\n        while len(self.rheap)-len(self.lheap)&gt;1:\n            v = heapq.heappop(self.rheap)\n            heapq.heappush(self.lheap, -v)\n\n    def findMedian(self) -&gt; float:\n        if len(self.lheap)==len(self.rheap):\n            lv = -self.lheap[0]\n            rv = self.rheap[0]\n            return (lv+rv)/2\n        return -self.lheap[0] if len(self.lheap)&gt;len(self.rheap) else self.rheap[0]",
    "crumbs": [
      "coding-problems",
      "heaps",
      "295. Find Median from Data Stream"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-502-ipo.html",
    "href": "coding-problems/heaps/lc-502-ipo.html",
    "title": "502. IPO",
    "section": "",
    "text": "link\nSuppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\nExample 1:\n\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\nExample 2:\n\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6",
    "crumbs": [
      "coding-problems",
      "heaps",
      "502. IPO"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-502-ipo.html#problem",
    "href": "coding-problems/heaps/lc-502-ipo.html#problem",
    "title": "502. IPO",
    "section": "",
    "text": "link\nSuppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\nExample 1:\n\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\nExample 2:\n\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6",
    "crumbs": [
      "coding-problems",
      "heaps",
      "502. IPO"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-502-ipo.html#constraints",
    "href": "coding-problems/heaps/lc-502-ipo.html#constraints",
    "title": "502. IPO",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= k &lt;= 105\n0 &lt;= w &lt;= 109\nn == profits.length\nn == capital.length\n1 &lt;= n &lt;= 105\n0 &lt;= profits[i] &lt;= 104\n0 &lt;= capital[i] &lt;= 109",
    "crumbs": [
      "coding-problems",
      "heaps",
      "502. IPO"
    ]
  },
  {
    "objectID": "coding-problems/heaps/lc-502-ipo.html#solution",
    "href": "coding-problems/heaps/lc-502-ipo.html#solution",
    "title": "502. IPO",
    "section": "Solution",
    "text": "Solution\n\ndef findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -&gt; int:\n        heap = []\n        projects = sorted(zip(profits, capital), key=lambda x: x[-1])\n        i = 0\n\n        for _ in range(k):\n            while i &lt; len(projects) and projects[i][-1] &lt;= w:\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            if heap:\n                w -= heapq.heappop(heap)\n        return w",
    "crumbs": [
      "coding-problems",
      "heaps",
      "502. IPO"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html",
    "href": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html",
    "title": "857. Minimum Cost to Hire K Workers",
    "section": "",
    "text": "link\nThere are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\nEvery worker in the paid group must be paid at least their minimum wage expectation.\nIn the group, each worker’s pay must be directly proportional to their quality. This means if a worker’s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\n\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10^-5 of the actual answer will be accepted.\nExample 1:\n\nInput: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0th worker and 35 to 2nd worker.\nExample 2:\n\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "857. Minimum Cost to Hire `K` Workers"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html#problem",
    "href": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html#problem",
    "title": "857. Minimum Cost to Hire K Workers",
    "section": "",
    "text": "link\nThere are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\nEvery worker in the paid group must be paid at least their minimum wage expectation.\nIn the group, each worker’s pay must be directly proportional to their quality. This means if a worker’s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\n\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10^-5 of the actual answer will be accepted.\nExample 1:\n\nInput: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0th worker and 35 to 2nd worker.\nExample 2:\n\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "857. Minimum Cost to Hire `K` Workers"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html#constraints",
    "href": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html#constraints",
    "title": "857. Minimum Cost to Hire K Workers",
    "section": "Constraints",
    "text": "Constraints\n\nn == quality.length == wage.length\n1 &lt;= k &lt;= n &lt;= 10^4\n1 &lt;= quality[i], wage[i] &lt;= 10^4",
    "crumbs": [
      "coding-problems",
      "arrays",
      "857. Minimum Cost to Hire `K` Workers"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html#solution",
    "href": "coding-problems/arrays/lc-857-minimum-cost-to-hire-k-workers.html#solution",
    "title": "857. Minimum Cost to Hire K Workers",
    "section": "Solution",
    "text": "Solution\n\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -&gt; float:\n\n        workers = sorted([(float(w)/q, q) for w,q in zip(wage, quality)])\n        res = float('inf')\n        qsum = 0\n        heap = []\n\n        for r, q in workers:\n            heapq.heappush(heap, -q)\n            qsum += q\n            if len(heap)&gt;k: qsum += heapq.heappop(heap)\n            if len(heap)==k: res = min(res, qsum*r)\n        \n        return res",
    "crumbs": [
      "coding-problems",
      "arrays",
      "857. Minimum Cost to Hire `K` Workers"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html",
    "href": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html",
    "title": "918. Maximum Sum Circular Subarray",
    "section": "",
    "text": "link\nGiven a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i &lt;= k1, k2 &lt;= j with k1 % n == k2 % n.\nExample 1:\n\nInput: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\nExample 2:\n\nInput: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\nExample 3:\n\nInput: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "918. Maximum Sum Circular Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html#problem",
    "href": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html#problem",
    "title": "918. Maximum Sum Circular Subarray",
    "section": "",
    "text": "link\nGiven a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i &lt;= k1, k2 &lt;= j with k1 % n == k2 % n.\nExample 1:\n\nInput: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\nExample 2:\n\nInput: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\nExample 3:\n\nInput: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "918. Maximum Sum Circular Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html#constraints",
    "href": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html#constraints",
    "title": "918. Maximum Sum Circular Subarray",
    "section": "Constraints",
    "text": "Constraints\n\nn == nums.length\n1 &lt;= n &lt;= 3 * 104\n-3 * 104 &lt;= nums[i] &lt;= 3 * 104",
    "crumbs": [
      "coding-problems",
      "arrays",
      "918. Maximum Sum Circular Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html#solution",
    "href": "coding-problems/arrays/lc-918-max-sum-circular-subarry.html#solution",
    "title": "918. Maximum Sum Circular Subarray",
    "section": "Solution",
    "text": "Solution\n\nSo the max subarray circular sum equals to max(the max subarray sum, the total sum - the min subarray sum)\n\nfrom typing import List\n\n\nclass Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -&gt; int:\n        \n        total, cmax, maxsum, cmin, minsum = 0, 0, nums[0], 0, nums[0]\n\n        for n in nums:\n            cmax = max(cmax + n, n)\n            maxsum = max(maxsum, cmax)\n            cmin = min(cmin + n, n)\n            minsum = min(minsum, cmin)\n            total += n\n        \n        return max(maxsum, total-minsum) if maxsum &gt; 0 else maxsum",
    "crumbs": [
      "coding-problems",
      "arrays",
      "918. Maximum Sum Circular Subarray"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-875-koko-eating-bananas.html",
    "href": "coding-problems/arrays/lc-875-koko-eating-bananas.html",
    "title": "875. Koko Eating Bananas",
    "section": "",
    "text": "link\nKoko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23",
    "crumbs": [
      "coding-problems",
      "arrays",
      "875. Koko Eating Bananas"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-875-koko-eating-bananas.html#problem",
    "href": "coding-problems/arrays/lc-875-koko-eating-bananas.html#problem",
    "title": "875. Koko Eating Bananas",
    "section": "",
    "text": "link\nKoko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23",
    "crumbs": [
      "coding-problems",
      "arrays",
      "875. Koko Eating Bananas"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-875-koko-eating-bananas.html#constraints",
    "href": "coding-problems/arrays/lc-875-koko-eating-bananas.html#constraints",
    "title": "875. Koko Eating Bananas",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= piles.length &lt;= 10^4\npiles.length &lt;= h &lt;= 10^9\n1 &lt;= piles[i] &lt;= 10^9",
    "crumbs": [
      "coding-problems",
      "arrays",
      "875. Koko Eating Bananas"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-875-koko-eating-bananas.html#solution",
    "href": "coding-problems/arrays/lc-875-koko-eating-bananas.html#solution",
    "title": "875. Koko Eating Bananas",
    "section": "Solution",
    "text": "Solution\n\nimport math\nfrom typing import List\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:\n\n        def feasible(speed) -&gt; bool:\n\n            return sum(math.ceil(pile/speed) for pile in piles) &lt;= h\n        \n        l, r = 1, max(piles)\n\n        while l&lt;r:\n            mid = (l+r)//2\n            if feasible(mid): r = mid\n            else: l = mid+1\n        \n        return l",
    "crumbs": [
      "coding-problems",
      "arrays",
      "875. Koko Eating Bananas"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-739-daily-temperature.html",
    "href": "coding-problems/arrays/lc-739-daily-temperature.html",
    "title": "739. Daily Temperatures",
    "section": "",
    "text": "link\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\nExample 1:\n\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\nExample 2:\n\nInput: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\nExample 3:\n\nInput: temperatures = [30,60,90]\nOutput: [1,1,0]",
    "crumbs": [
      "coding-problems",
      "arrays",
      "739. Daily Temperatures"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-739-daily-temperature.html#problem",
    "href": "coding-problems/arrays/lc-739-daily-temperature.html#problem",
    "title": "739. Daily Temperatures",
    "section": "",
    "text": "link\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\nExample 1:\n\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\nExample 2:\n\nInput: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\nExample 3:\n\nInput: temperatures = [30,60,90]\nOutput: [1,1,0]",
    "crumbs": [
      "coding-problems",
      "arrays",
      "739. Daily Temperatures"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-739-daily-temperature.html#constraints",
    "href": "coding-problems/arrays/lc-739-daily-temperature.html#constraints",
    "title": "739. Daily Temperatures",
    "section": "Constraints",
    "text": "Constraints\n\n1 &lt;= temperatures.length &lt;= 10^5\n30 &lt;= temperatures[i] &lt;= 100",
    "crumbs": [
      "coding-problems",
      "arrays",
      "739. Daily Temperatures"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-739-daily-temperature.html#solution",
    "href": "coding-problems/arrays/lc-739-daily-temperature.html#solution",
    "title": "739. Daily Temperatures",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:\n\n        answer = [0] * len(temperatures)\n        stack = []\n\n        for i, t in enumerate(temperatures):\n            while stack and temperatures[stack[-1]]&lt;t: # if the curr temp is &gt; than temps of previous days then update previous days values\n                cur = stack.pop()\n                answer[cur] = i-cur\n            stack.append(i) # add the index to the stack\n        \n        return answer",
    "crumbs": [
      "coding-problems",
      "arrays",
      "739. Daily Temperatures"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-11-container-with-most-water.html",
    "href": "coding-problems/arrays/lc-11-container-with-most-water.html",
    "title": "11. Container With Most Water",
    "section": "",
    "text": "link\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "arrays",
      "11. Container With Most Water"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-11-container-with-most-water.html#problem",
    "href": "coding-problems/arrays/lc-11-container-with-most-water.html#problem",
    "title": "11. Container With Most Water",
    "section": "",
    "text": "link\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1",
    "crumbs": [
      "coding-problems",
      "arrays",
      "11. Container With Most Water"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-11-container-with-most-water.html#constraints",
    "href": "coding-problems/arrays/lc-11-container-with-most-water.html#constraints",
    "title": "11. Container With Most Water",
    "section": "Constraints",
    "text": "Constraints\n\nn == height.length\n2 &lt;= n &lt;= 10^5\n0 &lt;= height[i] &lt;= 10^4",
    "crumbs": [
      "coding-problems",
      "arrays",
      "11. Container With Most Water"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-11-container-with-most-water.html#solution",
    "href": "coding-problems/arrays/lc-11-container-with-most-water.html#solution",
    "title": "11. Container With Most Water",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def maxArea(self, height: List[int]) -&gt; int:\n\n        n = len(height)\n        i, j = 0, n-1\n        ans = 0\n\n        while i&lt;j:\n            ans = max(ans, (j-i)*min(height[i], height[j]))\n\n            if height[i]&lt;height[j]: i+=1\n            else: j-=1\n        \n        return ans",
    "crumbs": [
      "coding-problems",
      "arrays",
      "11. Container With Most Water"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-135-candy.html",
    "href": "coding-problems/arrays/lc-135-candy.html",
    "title": "135. Candy",
    "section": "",
    "text": "link\nThere are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "135. Candy"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-135-candy.html#problem",
    "href": "coding-problems/arrays/lc-135-candy.html#problem",
    "title": "135. Candy",
    "section": "",
    "text": "link\nThere are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "135. Candy"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-135-candy.html#constraints",
    "href": "coding-problems/arrays/lc-135-candy.html#constraints",
    "title": "135. Candy",
    "section": "Constraints",
    "text": "Constraints\n\nn == ratings.length\n1 &lt;= n &lt;= 2 * 104\n0 &lt;= ratings[i] &lt;= 2 * 104",
    "crumbs": [
      "coding-problems",
      "arrays",
      "135. Candy"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-135-candy.html#solution",
    "href": "coding-problems/arrays/lc-135-candy.html#solution",
    "title": "135. Candy",
    "section": "Solution",
    "text": "Solution\n\nfrom typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -&gt; int:\n        n, candies = len(ratings), [1] * len(ratings)\n\n        for i in range(n-1):\n            if ratings[i] &lt; ratings[i+1]:\n                candies[i+1] = max(candies[i]+1, candies[i+1])\n        \n        for i in range(n-1, 0, -1):\n            if ratings[i] &lt; ratings[i-1]:\n                candies[i-1] = max(candies[i]+1, candies[i-1])\n        \n        return sum(candies)",
    "crumbs": [
      "coding-problems",
      "arrays",
      "135. Candy"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1493-longest-subarray-of-1s-after-deleting-one-element.html",
    "href": "coding-problems/arrays/lc-1493-longest-subarray-of-1s-after-deleting-one-element.html",
    "title": "1493. Longest Subarray of 1’s After Deleting One Element",
    "section": "",
    "text": "link\nGiven a binary array nums, you should delete one element from it.\nReturn the size of the longest non-empty subarray containing only 1’s in the resulting array. Return 0 if there is no such subarray.\nExample 1:\n\nInput: nums = [1,1,0,1]\nOutput: 3\nExplanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.\nExample 2:\n\nInput: nums = [0,1,1,1,0,1,1,0,1]\nOutput: 5\nExplanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].\nExample 3:\n\nInput: nums = [1,1,1]\nOutput: 2\nExplanation: You must delete one element.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1493. Longest Subarray of 1's After Deleting One Element"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1493-longest-subarray-of-1s-after-deleting-one-element.html#problem",
    "href": "coding-problems/arrays/lc-1493-longest-subarray-of-1s-after-deleting-one-element.html#problem",
    "title": "1493. Longest Subarray of 1’s After Deleting One Element",
    "section": "",
    "text": "link\nGiven a binary array nums, you should delete one element from it.\nReturn the size of the longest non-empty subarray containing only 1’s in the resulting array. Return 0 if there is no such subarray.\nExample 1:\n\nInput: nums = [1,1,0,1]\nOutput: 3\nExplanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.\nExample 2:\n\nInput: nums = [0,1,1,1,0,1,1,0,1]\nOutput: 5\nExplanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].\nExample 3:\n\nInput: nums = [1,1,1]\nOutput: 2\nExplanation: You must delete one element.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1493. Longest Subarray of 1's After Deleting One Element"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-1493-longest-subarray-of-1s-after-deleting-one-element.html#constraints",
    "href": "coding-problems/arrays/lc-1493-longest-subarray-of-1s-after-deleting-one-element.html#constraints",
    "title": "1493. Longest Subarray of 1’s After Deleting One Element",
    "section": "Constraints:",
    "text": "Constraints:\n\n1 &lt;= nums.length &lt;= 10^5\nnums[i] is either 0 or 1\n\n\nfrom typing import List\n\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -&gt; int:\n        n, nz = len(nums), 0\n        i = j = 0\n        sz = 0\n\n        while j&lt;n:\n            nz += not(nums[j])\n            while i&lt;j and nz&gt;1: \n                nz -= not(nums[i])\n                i += 1\n            sz = max(sz, j-i)\n            j += 1\n        \n        return sz",
    "crumbs": [
      "coding-problems",
      "arrays",
      "1493. Longest Subarray of 1's After Deleting One Element"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-74-search-a-2d-matrix.html",
    "href": "coding-problems/arrays/lc-74-search-a-2d-matrix.html",
    "title": "74. Search a 2D Matrix",
    "section": "",
    "text": "link\nYou are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\nExample 2:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false",
    "crumbs": [
      "coding-problems",
      "arrays",
      "74. Search a 2D Matrix"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-74-search-a-2d-matrix.html#problem",
    "href": "coding-problems/arrays/lc-74-search-a-2d-matrix.html#problem",
    "title": "74. Search a 2D Matrix",
    "section": "",
    "text": "link\nYou are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\nExample 2:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false",
    "crumbs": [
      "coding-problems",
      "arrays",
      "74. Search a 2D Matrix"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-74-search-a-2d-matrix.html#constraints",
    "href": "coding-problems/arrays/lc-74-search-a-2d-matrix.html#constraints",
    "title": "74. Search a 2D Matrix",
    "section": "Constraints:",
    "text": "Constraints:\n\nm == matrix.length\nn == matrix[i].length\n1 &lt;= m, n &lt;= 100\n-10^4 &lt;= matrix[i][j], target &lt;= 10^4",
    "crumbs": [
      "coding-problems",
      "arrays",
      "74. Search a 2D Matrix"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-74-search-a-2d-matrix.html#solution",
    "href": "coding-problems/arrays/lc-74-search-a-2d-matrix.html#solution",
    "title": "74. Search a 2D Matrix",
    "section": "Solution",
    "text": "Solution\nImagine the 2-D matric as a flattened array, flattened row by row. Then each element i in this array will be matrix[i//cols][i%cols]. Then we can use binary search to find the target in this array.\n\nfrom typing import List\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n\n        if not matrix or not matrix[0]: return False\n        R, C = len(matrix), len(matrix[0])\n        lo, hi = 0, R*C-1\n        while lo&lt;hi:\n            mid = (lo+hi)//2\n            mv = matrix[mid//C][mid%C]\n            if mv==target: return True\n            elif mv&lt;target: lo = mid+1\n            else: hi = mid-1\n        return matrix[lo//C][lo%C]==target",
    "crumbs": [
      "coding-problems",
      "arrays",
      "74. Search a 2D Matrix"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html",
    "href": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html",
    "title": "142. Linked List Cycle II",
    "section": "",
    "text": "Link\nGiven the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "142. Linked List Cycle II"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html#problem",
    "href": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html#problem",
    "title": "142. Linked List Cycle II",
    "section": "",
    "text": "Link\nGiven the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "142. Linked List Cycle II"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html#constraints",
    "href": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html#constraints",
    "title": "142. Linked List Cycle II",
    "section": "Constraints:",
    "text": "Constraints:\n\nThe number of the nodes in the list is in the range [0, 10^4].\n-10^5 &lt;= Node.val &lt;= 10^5\npos is -1 or a valid index in the linked-list.",
    "crumbs": [
      "coding-problems",
      "arrays",
      "142. Linked List Cycle II"
    ]
  },
  {
    "objectID": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html#solution",
    "href": "coding-problems/arrays/lc-142-linked-list-cycle-ii.html#solution",
    "title": "142. Linked List Cycle II",
    "section": "Solution",
    "text": "Solution\n\n\nfrom typing import Optional\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        fast, slow = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast==slow: break\n        else: return None\n        while head != slow:\n            head, slow = head.next, slow.next\n        return head",
    "crumbs": [
      "coding-problems",
      "arrays",
      "142. Linked List Cycle II"
    ]
  },
  {
    "objectID": "low-level-design/rate-limiter.html",
    "href": "low-level-design/rate-limiter.html",
    "title": "Rate Limiter",
    "section": "",
    "text": "RateLimiter\n\n RateLimiter (time_window:int=inf, num_requests:int=inf)\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\n\n\nSlidingWindowRateLimiter\n\n SlidingWindowRateLimiter (time_window:int=inf, num_requests:int=inf)\n\nHelper class that provides a standard way to create an ABC using inheritance.\n\n\n\nTokenBucketRateLimiter\n\n TokenBucketRateLimiter (time_window:int=inf, num_requests:int=inf)\n\nHelper class that provides a standard way to create an ABC using inheritance.",
    "crumbs": [
      "low-level-design",
      "Rate Limiter"
    ]
  }
]